<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javascript - 基础(equal)</title>
      <link href="/2022/04/02/javascript-equal/"/>
      <url>/2022/04/02/javascript-equal/</url>
      
        <content type="html"><![CDATA[<h3 id="相等的四种算法"><a href="#相等的四种算法" class="headerlink" title="相等的四种算法"></a>相等的四种算法</h3><ol><li>抽象（非严格）相等比较 (==)</li><li>严格相等比较 (===)</li><li>同值零</li><li>同值: 用于所有其他地方</li></ol><h3 id="JavaScript提供三种不同的值比较操作"><a href="#JavaScript提供三种不同的值比较操作" class="headerlink" title="JavaScript提供三种不同的值比较操作"></a>JavaScript提供三种不同的值比较操作</h3><ol><li>严格相等比较 (也被称作”strict equality”, “identity”, “triple equals”)，使用 === ,</li><li>抽象相等比较 (“loose equality”，”double equals”) ，使用 ==</li><li>以及 Object.is （ECMAScript 2015/ ES6 新特性）</li></ol><h4 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h4><p>全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。如果值为NaN则不相等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">console</span>.log(num === num); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj === obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(str === str); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(num === obj); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(num === str); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === str); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === <span class="hljs-literal">null</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="非严格相等"><a href="#非严格相等" class="headerlink" title="非严格相等 =="></a>非严格相等 ==</h3><p>相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。</p><p><img src="/image/equal/equal.jpg" alt="非严格相等判定" title="非严格相等判定"></p><p>ToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。ToPrimitive(A)通过尝试调用 A 的A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">console</span>.log(num == num); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj == obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(str == str); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(num == obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(num == str); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj == str); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// both false, except in rare cases</span><br><span class="hljs-built_in">console</span>.log(obj == <span class="hljs-literal">null</span>);<br><span class="hljs-built_in">console</span>.log(obj == <span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure><h4 id="相等比较的模型"><a href="#相等比较的模型" class="headerlink" title="相等比较的模型"></a>相等比较的模型</h4><p><img src="/image/equal/equal.png" alt="相等比较的区别" title="相等比较的区别"></p><p>需要注意的是</p><ol><li><code>Object.is(NaN, NaN)</code>的值为<strong>true</strong></li><li><code>Object.is(+0, -0)</code>的值为<strong>false</strong></li><li>全等时<code>NaN === NaN</code>的值为<strong>false</strong></li><li>全等时<code>+0 === -0</code>的值<strong>true</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础库</title>
      <link href="/2022/04/01/python-lib/"/>
      <url>/2022/04/01/python-lib/</url>
      
        <content type="html"><![CDATA[<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ol><li><p>引入json库</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br></code></pre></td></tr></table></figure></li><li><p>json方法</p><ul><li>json.dumps<br>将 Python 对象编码成 JSON 字符串（返回转换后的json字符串）</li></ul> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">json.dumps(obj, skipkeys=<span class="hljs-literal">False</span>, ensure_ascii=<span class="hljs-literal">True</span>, check_circular=<span class="hljs-literal">True</span>, allow_nan=<span class="hljs-literal">True</span>, cls=<span class="hljs-literal">None</span>, indent=<span class="hljs-literal">None</span>, separators=<span class="hljs-literal">None</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>, default=<span class="hljs-literal">None</span>, sort_keys=<span class="hljs-literal">False</span>, **kw)<br><span class="hljs-comment"># obj - 需要修改的 Python 对象</span><br><span class="hljs-comment"># skipkeys - 默认值是 False，如果dict的keys内的数据不是python的基本类型(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key 。</span><br><span class="hljs-comment"># ensure_ascii - 默认输出ASCLL码，如果把这个该成False,就可以输出中文。</span><br><span class="hljs-comment"># check_circular - 如果check_circular为 False ，则跳过对容器类型的循环引用检查，循环引用将导致溢出错误(或更糟的情况)。</span><br><span class="hljs-comment"># allow_nan - 如果allow_nan为假，则ValueError将序列化超出范围的浮点值(nan、inf、-inf)，严格遵守JSON规范，而不是使用JavaScript等价值(nan、Infinity、-Infinity)。</span><br><span class="hljs-comment"># indent - 参数根据数据格式缩进显示，读起来更加清晰。</span><br><span class="hljs-comment"># separators - 是分隔符的意思，参数意思分别为不同dict项之间的分隔符和dict项内key和value之间的分隔符，把：和，后面的空格都除去了。</span><br><span class="hljs-comment"># sort_keys - True是告诉编码器按照字典排序(a到z)输出。如果是字典类型的python对象，就把关键字按照字典排序。</span><br></code></pre></td></tr></table></figure><ul><li>json.dump<br>把python对象转换成json对象生成一个fp的文件流，和文件相关。python对象转换为字符串并且写入文件</li></ul> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-comment">#将python对象转换为json字符串</span><br>persons = [<br>    &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&quot;zhaoji&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span>,<br>        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;China&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;cyj&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span>,<br>        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;China&quot;</span><br>    &#125;<br>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/j1.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(persons, fp) // 将person存成文件<br></code></pre></td></tr></table></figure><ul><li>json.loads是用来读取字符串,可以把文件打开，用readline()读取一行，然后json.loads()一行。</li><li>json.load是用来读取文件的，即，将文件打开然后就可以直接读取。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相似模型</title>
      <link href="/2022/04/01/similar-model/"/>
      <url>/2022/04/01/similar-model/</url>
      
        <content type="html"><![CDATA[<h3 id="常见相似算法"><a href="#常见相似算法" class="headerlink" title="常见相似算法"></a>常见相似算法</h3><ol><li>欧德里得距离</li><li>皮尔逊相关系数</li><li>余弦相似度</li><li>Tanimoto系数（广义Jaccard相似系数）</li></ol><h4 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h4><p>Pearson 相关系数是用<strong>协方差</strong><em><strong>除以</strong></em>两个变量的<strong>标准差</strong>得到的，虽然协方差能反映两个随机变量的相关程度（协方差大于0的时候表示两者正相关，小于0的时候表示两者负相关），但其数值上受量纲的影响很大，不能简单地从协方差的数值大小给出变量相关程度的判断。为了消除这种量纲的影响，于是就有了相关系数的概念。<br>当两个变量的方差都不为零时，相关系数才有意义，相关系数的取值范围为[-1,1]。《数据挖掘导论》中给了一个很形象的图来说明相关度大小与相关系数之间的联系：</p><p><img src="/image/similar-model/pearson.png" alt="皮尔逊相关系数" title="皮尔逊相关系数"></p><p>由上图可以总结，当相关系数为1时，成为完全正相关；当相关系数为-1时，成为完全负相关；相关系数的绝对值越大，相关性越强；相关系数越接近于0，相关度越弱。</p><p><strong>皮尔逊相关的约束条件:</strong></p><ul><li>两个变量间有线性关系</li><li>变量是连续变量</li><li>变量均符合正态分布,且二元分布也符合正态分布</li><li>两变量独立</li></ul><p>在实践统计中,一般只输出两个系数,一个是相关系数,也就是计算出来的相关系数大小,在-1到1之间;另一个是独立样本检验系数,用来检验样本一致性.</p><h4 id="相似患者模型流程"><a href="#相似患者模型流程" class="headerlink" title="相似患者模型流程"></a>相似患者模型流程</h4><ol><li>相似患者模型流程</li></ol><p><img src="/image/similar-model/process.png" alt="相似患者模型流程" title="相似患者模型流程"><br>2. 相似患者模型</p><p><img src="/image/similar-model/similar-model.jpg" alt="相似患者模型" title="相似患者模型"><br>3. 相似患者功能</p><p><img src="/image/similar-model/function.png" alt="相似患者功能" title="相似患者功能"></p>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sk-learn</title>
      <link href="/2022/04/01/sk-learn/"/>
      <url>/2022/04/01/sk-learn/</url>
      
        <content type="html"><![CDATA[<h3 id="安装sk-learn"><a href="#安装sk-learn" class="headerlink" title="安装sk-learn"></a>安装sk-learn</h3><h4 id="pip-简介"><a href="#pip-简介" class="headerlink" title="pip 简介"></a>pip 简介</h4><p>Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一.</p><p>Sklearn 包含了很多种机器学习的方式:</p><p>Classification 分类</p><p>Regression 回归</p><p>Clustering 非监督分类</p><p>Dimensionality reduction 数据降维</p><p>Model Selection 模型选择</p><p>Preprocessing 数据预处理</p><h4 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装条件</span><br><span class="hljs-comment"># Python (&gt;=2.6 或 &gt;=3.3 版本)</span><br><span class="hljs-comment"># Numpy (&gt;=1.6.1)</span><br><span class="hljs-comment"># Scipy (&gt;=0.9)</span><br><br><span class="hljs-comment"># python 2+ 版本</span><br>pip install sciket-learn<br><br><span class="hljs-comment"># python 3+ 版本</span><br>pip3 install sciket-learn<br><br><span class="hljs-comment">#如果你是 Windows 用户, 你也可以选择使用 Anaconda 来安装所有 python 的科学计算模块. Anaconda的相关资料在这</span><br></code></pre></td></tr></table></figure><h4 id="sk-learn-工作流程"><a href="#sk-learn-工作流程" class="headerlink" title="sk-learn 工作流程"></a>sk-learn 工作流程</h4><ol><li>实例化要使用的特定机器学习模型</li><li>使模型适合训练数据</li><li>使用模型进行预测</li><li>评估预测的准确性</li></ol><h4 id="sk-learn-数据集分割"><a href="#sk-learn-数据集分割" class="headerlink" title="sk-learn 数据集分割"></a>sk-learn 数据集分割</h4><ol><li><p>留出法<br>基本思想是将数据集D（即我们获得的所有样本数据）划分为两个互斥的集合，将其中一个作为训练集S，另一个作为验证集T，即D=SUT，S∩T=Φ。在S上训练出模型后，再用T来评估其测试误差，作为泛化误差的估计值；</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train, X_test, y_train, y_test = train_test_split() <br><br><span class="hljs-comment"># X：待分割的样本集中的自变量部分，通常为二维数组或矩阵的形式；</span><br><span class="hljs-comment"># y：待分割的样本集中的因变量部分，通常为一维数组；</span><br><span class="hljs-comment"># test_size：用于指定验证集所占的比例，有以下几种输入类型：</span><br>　　  <span class="hljs-comment"># float型，0.0~1.0之间，此时传入的参数即作为验证集的比例；</span><br>　　  <span class="hljs-comment"># int型，此时传入的参数的绝对值即作为验证集样本的数量；</span><br>　　  <span class="hljs-comment"># None，这时需要另一个参数train_size有输入才生效，此时验证集去为train_size指定的比例或数量的补集；</span><br>　　  <span class="hljs-comment"># 缺省时为0.25，但要注意只有在train_size和test_size都不输入值时缺省值才会生效；</span><br><span class="hljs-comment"># train_size：基本同test_size，但缺省值为None，其实test_size和train_size输入一个即可；</span><br><span class="hljs-comment"># random_state：int型，控制随机数种子，默认为None，即纯随机（伪随机）；</span><br><span class="hljs-comment"># stratify：控制分类问题中的分层抽样，默认为None，即不进行分层抽样，当传入为数组时，则依据该数组进行分层抽样（一般传入因变量所在列）；</span><br><span class="hljs-comment"># shuffle：bool型，用来控制是否在分割数据前打乱原数据集的顺序，默认为True，分层抽样时即stratify为None时该参数必须传入False；</span><br></code></pre></td></tr></table></figure></li><li><p>交叉验证法</p></li><li><p>基于生成器的采样方法</p></li></ol><h4 id="sk-learn-数据缩放"><a href="#sk-learn-数据缩放" class="headerlink" title="sk-learn 数据缩放"></a>sk-learn 数据缩放</h4><ol><li><p>标准缩放（Standard Scaler）<br> StandardScaler假定你的数据正态分布在每个要素中，并将对其进行缩放，以使分布现在以0为中心，标准偏差为1。<br> 计算特征的平均值和标准偏差，然后根据以下条件对特征进行缩放：</p><p> <img src="/image/md-image/python%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE1.png" alt="&quot;标准缩放（Standard Scaler）&quot;" title="标准缩放（Standard Scaler）"><br> 如果数据<strong>不是正态分布</strong>的，那么这<strong>不算是最佳的缩放方法</strong>。</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler  <span class="hljs-comment"># 标准化工具</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x_np = np.array([[<span class="hljs-number">1.5</span>, -<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>],<br>              [<span class="hljs-number">2.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])<br>scaler = StandardScaler()<br>x_train = scaler.fit_transform(x_np)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;矩阵初值为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x_np))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该矩阵的均值为：&#123;&#125;\n 该矩阵的标准差为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(scaler.mean_,np.sqrt(scaler.var_)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;标准差标准化的矩阵为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x_train))<br><br><span class="hljs-comment"># 矩阵初值为：[[ 1.5 -1.   2. ]</span><br><span class="hljs-comment">#             [ 2.   0.   0. ]]</span><br><span class="hljs-comment"># 该矩阵的均值为：   [ 1.75 -0.5   1.  ]</span><br><span class="hljs-comment"># 该矩阵的标准差为：[0.25 0.5  1.  ]</span><br><span class="hljs-comment"># 标准差标准化的矩阵为：[[-1. -1.  1.]</span><br><span class="hljs-comment">#                      [ 1.  1. -1.]]</span><br></code></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">StandardScaler()的方法<br>fit():<br>  <span class="hljs-number">1.</span> 功能：<br>    计算均值和标准差，用于以后的缩放。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组，形如(样本的数量，特征的数量)<br>      训练集<br>fit_transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    先计算均值、标准差，再标准化<br>  <span class="hljs-number">2.</span> 参数:<br>    X: 二维数组<br>transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    通过居中和缩放执行标准化。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组<br>      该数据沿着特征轴。<br>inverse_transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    将数据按比例恢复到以前的大小。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组，形如(样本数量，特征数量)、<br>容易犯的错误<br>错误输入一维数组给fit_transform()、transform()。<br>原因是，标准化是对列操作的，一维数组每列中只有一个值，无法计算。<br>解决是，通过reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)，将一维数组改为二维数组。<br></code></pre></td></tr></table></figure></li><li><p>最大最小值缩放（Min-Max Scaler）</p></li><li><p>稳健缩放 （Roburst Scaler）</p></li><li><p>归一化（Normalizer）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sk-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2021/10/08/python-numpy/"/>
      <url>/2021/10/08/python-numpy/</url>
      
        <content type="html"><![CDATA[<h3 id="1-numpy简介"><a href="#1-numpy简介" class="headerlink" title="1.numpy简介"></a>1.numpy简介</h3><p>NumPy是用Python进行科学计算的基础软件包。<br>具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><ol><li>功能强大的N维数组对象。</li><li>精密广播功能函数。</li><li>集成 C/C+和Fortran 代码的工具。</li><li>强大的线性代数、傅立叶变换和随机数功能。</li></ol><h3 id="2-numpy环境安装"><a href="#2-numpy环境安装" class="headerlink" title="2.numpy环境安装"></a>2.numpy环境安装</h3><p>numpy 安装</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install numpy<br></code></pre></td></tr></table></figure><h3 id="3-numpy数组创建"><a href="#3-numpy数组创建" class="headerlink" title="3.numpy数组创建"></a>3.numpy数组创建</h3><p>ndarray：N维数组对象（矩阵），所有元素必须是相同类型。<br>ndarray属性：<code>ndim</code> 属性，表示维度个数；<code>shape</code> 属性，表示各维度大小；<code>dtype</code> 属性，表示数据类型。<br /><br><img src="/image/numpy-image/numpy-narray.png" alt="&quot;numpy创建数组&quot;" title="numpy创建数组"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例代码</span><br><br><span class="hljs-keyword">import</span> numpy;<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用列表生成一维数组&#x27;</span><br>data = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>x = numpy.array(data)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment">#打印数组</span><br><span class="hljs-built_in">print</span> x.dtype <span class="hljs-comment">#打印数组元素的类型</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用列表生成二维数组&#x27;</span><br>data = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br>x = numpy.array(data)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment">#打印数组</span><br><span class="hljs-built_in">print</span> x.ndim <span class="hljs-comment">#打印数组的维度</span><br><span class="hljs-built_in">print</span> x.shape <span class="hljs-comment">#打印数组各个维度的长度。shape是一个元组</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用zero/ones/empty创建数组:根据shape来创建&#x27;</span><br>x = numpy.zeros(<span class="hljs-number">6</span>) <span class="hljs-comment">#创建一维长度为6的，元素都是0一维数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3的二维0数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3的二维1数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.empty((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3,未初始化的二维数组</span><br><span class="hljs-built_in">print</span> x<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用arrange生成连续元素&#x27;</span><br><span class="hljs-built_in">print</span> numpy.arange(<span class="hljs-number">6</span>) <span class="hljs-comment"># [0,1,2,3,4,5,] 开区间</span><br><span class="hljs-built_in">print</span> numpy.arange(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment"># [0, 2，4]</span><br></code></pre></td></tr></table></figure><h3 id="4-ndarray数组元素的类型"><a href="#4-ndarray数组元素的类型" class="headerlink" title="4.ndarray数组元素的类型"></a>4.ndarray数组元素的类型</h3><p><img src="/image/numpy-image/numpy-dtype.jpg" alt="&quot;numpy创建数组&quot;" title="numpy创建数组"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例代码</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;生成指定元素类型的数组:设置dtype属性&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">3</span>],dtype = numpy.int64)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># 元素类型为int64</span><br><span class="hljs-built_in">print</span> x.dtype<br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],dtype = numpy.float64)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># 元素类型为float64</span><br><span class="hljs-built_in">print</span> x.dtype<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用astype复制数组，并转换类型&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">3</span>],dtype = numpy.float64)<br>y = x.astype(numpy.int32)<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [1 2 3]</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 1.   2.6  3. ]</span><br>z = y.astype(numpy.float64)<br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [ 1.  2.  3.]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;将字符串元素转换为数值元素&#x27;</span><br>x = numpy.array([<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>],dtype = numpy.string_)<br>y = x.astype(numpy.int32)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [&#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27;]</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [1 2 3] 若转换失败会抛出异常</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用其他数组的数据类型作为参数&#x27;</span><br>x = numpy.array([ <span class="hljs-number">1.</span>, <span class="hljs-number">2.6</span>,<span class="hljs-number">3.</span> ],dtype = numpy.float32);<br>y = numpy.arange(<span class="hljs-number">3</span>,dtype=numpy.int32);<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [0 1 2]</span><br><span class="hljs-built_in">print</span> y.astype(x.dtype) <span class="hljs-comment"># [ 0.  1.  2.]</span><br></code></pre></td></tr></table></figure><h3 id="5-ndarray的矢量化计算"><a href="#5-ndarray的矢量化计算" class="headerlink" title="5.ndarray的矢量化计算"></a>5.ndarray的矢量化计算</h3><p>矢量运算：相同大小的数组键间的运算应用在元素上<br>矢量和标量运算：“广播”— 将标量“广播”到各个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray数组与标量/数组的运算&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <br><span class="hljs-built_in">print</span> x*<span class="hljs-number">2</span> <span class="hljs-comment"># [2 4 6]</span><br><span class="hljs-built_in">print</span> x&gt;<span class="hljs-number">2</span> <span class="hljs-comment"># [False False  True]</span><br>y = numpy.array([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> x+y <span class="hljs-comment"># [4 6 8]</span><br><span class="hljs-built_in">print</span> x&gt;y <span class="hljs-comment"># [False False False]</span><br></code></pre></td></tr></table></figure><h3 id="6-ndarray数组的基本索引和切片"><a href="#6-ndarray数组的基本索引和切片" class="headerlink" title="6.ndarray数组的基本索引和切片"></a>6.ndarray数组的基本索引和切片</h3><p>一维数组的索引：与Python的列表索引功能相似;<br>多维数组的索引：</p><ol><li>arr[r1:r2, c1:c2]</li><li>arr[1,1] 等价 arr[1][1]</li><li>[:] 代表某个维度的数据</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的基本索引&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [1,2]</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-comment"># 2,普通python数组的索引</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] <span class="hljs-comment"># 同x[0][1]，ndarray数组的索引</span><br>x = numpy.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [[1 2],[3 4]]</span><br>y = x[<span class="hljs-number">0</span>].copy() <span class="hljs-comment"># 生成一个副本</span><br>z = x[<span class="hljs-number">0</span>] <span class="hljs-comment"># 未生成一个副本</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment">#  [[1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment"># 1</span><br>y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <br>z[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [[0 2],[3 4]]</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [[-1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [[-1 2],[3 4]]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的切片&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment"># [2,3] 右边开区间</span><br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">3</span>] <span class="hljs-comment"># [1,2,3] 左边默认为 0</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">1</span>:] <span class="hljs-comment"># [2,3,4,5] 右边默认为元素个数</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>] <span class="hljs-comment"># [1,3] 下标递增2</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">2</span>] <span class="hljs-comment"># [[1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] <span class="hljs-comment"># [[1],[3]]</span><br>x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> <span class="hljs-comment"># 用标量赋值</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[0,2],[0,4],[5,6]]</span><br>x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] = [[<span class="hljs-number">8</span>],[<span class="hljs-number">6</span>]] <span class="hljs-comment"># 用数组赋值</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[8,2],[6,4],[5,6]]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy-api函数</title>
      <link href="/2021/10/08/python-numpy-api/"/>
      <url>/2021/10/08/python-numpy-api/</url>
      
        <content type="html"><![CDATA[<h3 id="1-ndarray通用函数"><a href="#1-ndarray通用函数" class="headerlink" title="1.ndarray通用函数"></a>1.ndarray通用函数</h3><p>通用函数（ufunc）是一种对ndarray中的数据执行元素级运算的函数。<br /></p><div style="display:flex;margin-top:10px">  <img src="/image/numpy-image/numpy-api.png" style="width:49%">  <img src="/image/numpy-image/numpy-2-api.png" style="width:49%"></div><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;一元ufunc示例&#x27;</span><br>x = numpy.arange(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [0 1 2 3 4 5]</span><br><span class="hljs-built_in">print</span> numpy.square(x) <span class="hljs-comment"># [ 0  1  4  9 16 25]</span><br>x = numpy.array([<span class="hljs-number">1.5</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">1.8</span>])<br>y,z = numpy.modf(x)<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [ 0.5  0.6  0.7  0.8]</span><br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [ 1.  1.  1.  1.]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;二元ufunc示例&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]])<br>y = numpy.array([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">8</span>]])<br><span class="hljs-built_in">print</span> numpy.maximum(x,y) <span class="hljs-comment"># [[2,4],[6,8]]</span><br><span class="hljs-built_in">print</span> numpy.minimum(x,y) <span class="hljs-comment"># [[1,3],[5,7]]</span><br></code></pre></td></tr></table></figure><h3 id="2-NumPy的where函数"><a href="#2-NumPy的where函数" class="headerlink" title="2.NumPy的where函数"></a>2.NumPy的where函数</h3><p>p.where(condition, x, y)，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;where函数的使用&#x27;</span><br>cond = numpy.array([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>])<br>x = numpy.where(cond,-<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [-2  2 -2  2]</span><br>cond = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 2  2 -2 -2]</span><br>y1 = numpy.array([-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>])<br>y2 = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">2</span>,y1,y2) <span class="hljs-comment"># 长度须匹配</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [1,2,-3,-4]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;where函数的嵌套使用&#x27;</span><br>y1 = numpy.array([-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>,-<span class="hljs-number">5</span>,-<span class="hljs-number">6</span>])<br>y2 = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>y3 = numpy.zeros(<span class="hljs-number">6</span>)<br>cond = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">5</span>,y3,numpy.where(cond&gt;<span class="hljs-number">2</span>,y1,y2))<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 1.  2. -3. -4. -5.  0.]</span><br></code></pre></td></tr></table></figure><h3 id="3-ndarray常用的统计方法"><a href="#3-ndarray常用的统计方法" class="headerlink" title="3.ndarray常用的统计方法"></a>3.ndarray常用的统计方法</h3><p>可以通过这些基本统计方法对整个数组/某个轴的数据进行统计计算。</p><ul><li><strong>sum:</strong> 对数组中全部或莫轴向的元素求和。0长度的数组sum为0</li><li><strong>mean:</strong> 算术平均数，0长度的数组mean为NaN</li><li><strong>std、var:</strong> 标准差和方差</li><li><strong>min、max</strong> 最大值和最小值</li><li><strong>argmin、argmax:</strong> 最大元素和最小元素的索引</li><li><strong>cumsum:</strong> 所有元素的累计和</li><li><strong>cumprod</strong> 所有元素的累计积  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;numpy的基本统计方法&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]) <span class="hljs-comment">#同一维度上的数组长度须一致</span><br><span class="hljs-built_in">print</span> x.mean() <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span> x.mean(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 对每一行的元素求平均</span><br><span class="hljs-built_in">print</span> x.mean(axis=<span class="hljs-number">0</span>) <span class="hljs-comment"># 对每一列的元素求平均</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment">#同理 12</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [3 6 3]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">max</span>() <span class="hljs-comment"># 3</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">max</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [2 3 2]</span><br><span class="hljs-built_in">print</span> x.cumsum() <span class="hljs-comment"># [ 1  3  6  9 10 12]</span><br><span class="hljs-built_in">print</span> x.cumprod() <span class="hljs-comment"># [ 1  2  6 18 18 36]</span><br></code></pre></td></tr></table></figure><p>用于布尔数组的统计方法：</p><ul><li><strong>sum:</strong> 统计数组/数组某一维度中的True的个数</li><li><strong>any:</strong> 统计数组/数组某一维度中是否存在一个/多个True</li><li><strong>all:</strong> 统计数组/数组某一维度中是否都是True</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;用于布尔数组的统计方法&#x27;</span><br>x = numpy.array([[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>],[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>]])<br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [1,1]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">any</span>(axis=<span class="hljs-number">0</span>) <span class="hljs-comment"># [True,False]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">all</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [False,False]</span><br></code></pre></td></tr></table></figure><p>使用<strong>sort</strong>对数组/数组某一维度进行就地排序（会修改数组本身）。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;.sort的就地排序&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]])<br>x.sort(axis=<span class="hljs-number">1</span>) <br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[1 2 6] [1 3 6] [1 2 5]]</span><br><span class="hljs-comment">#非就地排序：numpy.sort()可产生数组的副本</span><br></code></pre></td></tr></table></figure><h3 id="4-ndarray数组的去重以及集合运算"><a href="#4-ndarray数组的去重以及集合运算" class="headerlink" title="4.ndarray数组的去重以及集合运算"></a>4.ndarray数组的去重以及集合运算</h3><ul><li><strong>unique(x):</strong> 计算x中的唯一元素，并返回有序结果</li><li><strong>instersect1d(x,y):</strong> 计算x和y中的公共元素，并返回有序结果</li><li><strong>union1d(x,y):</strong> 计算x和y的并集，并返回有序结果</li><li><strong>in1d(x,y):</strong> 得到一个表示“x的元素是否包含于y”的布尔型数组</li><li><strong>setdiff1d(x,y):</strong> 集合的差，即元素在x中且不在y中</li><li><strong>setxor1d(x,y):</strong> 集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的唯一化和集合运算&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]])<br><span class="hljs-built_in">print</span> numpy.unique(x) <span class="hljs-comment"># [1,2,3,5,6]</span><br>y = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> numpy.in1d(x,y) <span class="hljs-comment"># [ True  True False  True  True False  True  True False]</span><br><span class="hljs-built_in">print</span> numpy.setdiff1d(x,y) <span class="hljs-comment"># [2 3]</span><br><span class="hljs-built_in">print</span> numpy.intersect1d(x,y) <span class="hljs-comment"># [1 5 6]</span><br></code></pre></td></tr></table></figure><h3 id="5-numpy中的线性代数"><a href="#5-numpy中的线性代数" class="headerlink" title="5.numpy中的线性代数"></a>5.numpy中的线性代数</h3><ul><li><strong>diag:</strong> 以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成方阵（非对角线元素为0）</li><li><strong>dot:</strong> 矩阵乘法</li><li><strong>trace:</strong> 计算对角线元素的和</li><li><strong>det:</strong> 计算矩阵行列式</li><li><strong>eig:</strong> 计算方阵的本征值和本征向量</li><li><strong>inv:</strong> 计算方阵的逆</li><li><strong>pinv:</strong> 计算矩阵的Moore-Penrose伪逆</li><li><strong>qr:</strong> 计算QR分解</li><li><strong>svd:</strong> 计算奇异值分解（SVD）</li><li><strong>solve:</strong> 解线性方程组Ax = b，其中A为一个方阵</li><li><strong>lstsq</strong> 计算Ax = b的最小二乘解</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;线性代数&#x27;</span><br><span class="hljs-keyword">import</span> numpy.linalg <span class="hljs-keyword">as</span> nla<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;矩阵点乘&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br>y = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]])<br><span class="hljs-built_in">print</span> x.dot(y) <span class="hljs-comment"># [[ 5 11][11 25]]</span><br><span class="hljs-built_in">print</span> numpy.dot(x,y) <span class="hljs-comment"># # [[ 5 11][11 25]]</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;矩阵求逆&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]])<br>y = nla.inv(x) <span class="hljs-comment"># 矩阵求逆（若矩阵的逆存在）</span><br><span class="hljs-built_in">print</span> x.dot(y) <span class="hljs-comment"># 单位矩阵 [[ 1.  0.][ 0.  1.]]</span><br><span class="hljs-built_in">print</span> nla.det(x) <span class="hljs-comment"># 求行列式</span><br></code></pre></td></tr></table></figure><h3 id="6-numpy中的随机数生成"><a href="#6-numpy中的随机数生成" class="headerlink" title="6.numpy中的随机数生成"></a>6.numpy中的随机数生成</h3>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ai 机器学习初识</title>
      <link href="/2021/08/20/ai/"/>
      <url>/2021/08/20/ai/</url>
      
        <content type="html"><![CDATA[<h4 id="机器学习流程"><a href="#机器学习流程" class="headerlink" title="机器学习流程"></a>机器学习流程</h4><ol><li><p>模型选择:选择对应<strong>模型算法</strong>（例如：线性回归、逻辑回归、神经网络、决策树、支持向量机）</p></li><li><p>模型理解:了解模型的<strong>使用场景</strong>、<strong>所需参数</strong>以及<strong>数学意义</strong></p></li><li><p>数据准备:为保证模型准确性需要求：1.数据足够<strong>多</strong>2.数据足够<strong>全</strong>3.数据足够<strong>权威</strong></p></li><li><p>轴确认:选择特征作为模型的<code>X</code>轴，选择模型需要预测的结果为<code>Y</code>轴</p></li><li><p>数据清洗:对数据进行<strong>分组统计</strong>，对特征值筛选（<strong>mRMR算法</strong> =&gt; 最大相关和最小冗余） 最后将<strong>特征缩放</strong></p><ul><li><strong>mRMR</strong>（Max-Relevance and Min-Redundancy）：在原始特征集合中找到与最终输出结果相关性最大（Max-Relevance），和特征彼此之间相关性最小的一组特征（Min-Redundancy）</li><li><strong>特征缩放</strong>：用来统一资料中的自变项或特征范围的方法，特征缩放可以使机器学习算法工作的更好。</li></ul></li><li><p>训练模型:随机选取一部分（70%） 运行模型算法（Y = kX + k₂X₂ ···）,大致算出每个特征的权重k</p><ul><li><strong>模型算法</strong>：例如sk-learn中的逻辑回归LogisticRegression</li></ul></li><li><p>模型存储:存储运行后的模型公式（输入为带有这些特征的数据，输出为正的概率和为负的概率）</p></li><li><p>模型验证:再选另外一部分（30%） 运行模型公式，推算出<strong>tp</strong>（预测为正，实现也为正）<strong>fp</strong>（预测为负，实现为正）<strong>tn</strong>（预测为负，实现为负） <strong>fn</strong>（预测为负，实现为正）</p></li><li><p>根据预测的准确度经过公式推导</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// (精度) 精确率</span><br>P = 识别出的正确的正样本的数目 / 预测为正样本的数目<br><span class="hljs-comment">// (召回率) 或覆盖率</span><br>R = 识别出的正确的正样本的数目 / 实际为正样本的数目 <br><span class="hljs-comment">// 调和平均值</span><br>F1 是精确度和召回率的 <br>F1 = 2P×R / P+R<br><span class="hljs-comment">// 精确度和召回率都高时， F1值也会高． </span><br><span class="hljs-comment">// F1值在1时达到最佳值（完美的精确度和召回率 也就是 P = 1 ， R = 1），</span><br><span class="hljs-comment">// 最差为0．在二元分类中， F1值是测试准确度的量度。</span><br><span class="hljs-attr">TP</span>: 预测为正， 实现为正<br><span class="hljs-attr">FP</span>: 预测为正， 实现为负<br><span class="hljs-attr">FN</span>: 预测为负，实现为正<br><span class="hljs-attr">TN</span>: 预测为负， 实现为负 <br></code></pre></td></tr></table></figure></li><li><p>把数据传给前端绘制对应的<strong>模型好坏ROC</strong>的曲线</p></li><li><p>模型预测:输入对应的特征值，使用存储的模型预测结果（输入为带有这些特征的数据，输出为正的概率和为负的概率）</p></li></ol><h4 id="技术支持-python路线"><a href="#技术支持-python路线" class="headerlink" title="技术支持(python路线)"></a>技术支持(python路线)</h4><ol><li>python 语言基础</li><li>numpy (python数据处理库)</li><li>pandas (python数据处理库基于numpy)</li><li>sk-learn (科学计算库，机器学习基础库)</li><li>tensorflow (张量)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue：watch，computed</title>
      <link href="/2020/11/03/vue-(data,computed,watch)/"/>
      <url>/2020/11/03/vue-(data,computed,watch)/</url>
      
        <content type="html"><![CDATA[<h3 id="重写结果"><a href="#重写结果" class="headerlink" title="重写结果"></a>重写结果</h3><p>实现基本的数据劫持、computed缓存、watch</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vue&quot;</span>;<br><br><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    &#125;;<br>  &#125;,<br><br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">total</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-built_in">this</span>.b;<br>    &#125;,<br>  &#125;,<br><br>  <span class="hljs-attr">watch</span>: &#123;<br>    a (newValue, oldValue) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;newValue&quot;</span>, newValue);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;oldValue&quot;</span>, oldValue)<br>    &#125;,<br><br>    b (newValue, oldValue) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;newValue&quot;</span>, newValue);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;oldValue&quot;</span>, oldValue)<br>    &#125;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 2</span><br><br><br>vm.a = <span class="hljs-number">100</span><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 100</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 102</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 2</span><br><br>vm.b = <span class="hljs-number">200</span><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 100</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 300</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure><h3 id="重写思路"><a href="#重写思路" class="headerlink" title="重写思路"></a>重写思路</h3><h4 id="暴露外部js"><a href="#暴露外部js" class="headerlink" title="暴露外部js"></a>暴露外部js</h4><ol><li>路径：/vue/index</li><li>思路：整合reactive、computed和watch并暴露vue的构造函数</li><li>代码</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> reactive <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reactive&quot;</span><br><span class="hljs-keyword">import</span> Computed <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./computed&#x27;</span><br><span class="hljs-keyword">import</span> Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watch&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">options</span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123; data, computed, watch &#125; = options<br>    <span class="hljs-built_in">this</span>.$data = data()<br><br>    <span class="hljs-built_in">this</span>.init(computed, watch)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">computed, watch</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.initData()<br>    <span class="hljs-built_in">this</span>.$computed =  <span class="hljs-built_in">this</span>.initComputed(computed)<br>    <span class="hljs-built_in">this</span>.$watch =  <span class="hljs-built_in">this</span>.initWatcher(watch)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">initData</span>(<span class="hljs-params"></span>)</span>&#123;<br>    reactive(<span class="hljs-built_in">this</span>, <span class="hljs-function">(<span class="hljs-params">key,value</span>)=&gt;</span>&#123;<br><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">key, newValue, oldValue</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(newValue === oldValue) <span class="hljs-keyword">return</span><br>      <span class="hljs-built_in">this</span>.$computed.update(key)<br>      <span class="hljs-built_in">this</span>.$watch.trigger(key, newValue, oldValue)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initComputed</span>(<span class="hljs-params">computed</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> computedIns = <span class="hljs-keyword">new</span> Computed()<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> computed)&#123;<br>      computedIns.addComputed(<span class="hljs-built_in">this</span>, computed, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> computedIns<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initWatcher</span>(<span class="hljs-params">watch</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> watcherIns = <span class="hljs-keyword">new</span> Watcher()<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> watch)&#123;<br>      watcherIns.addWatcher(<span class="hljs-built_in">this</span>, watch, key)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> watcherIns<br>  &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Vue<br></code></pre></td></tr></table></figure><h4 id="reactive数据劫持"><a href="#reactive数据劫持" class="headerlink" title="reactive数据劫持"></a>reactive数据劫持</h4><ol><li>路径：/vue/reactive.js</li><li>思路：利用Object.defineProperty实现数据劫持并利用回调返回get，set</li><li>代码</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span> (<span class="hljs-params">vm, __get__, __set__</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> _data = vm.$data<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> _data)&#123;<br>    <span class="hljs-built_in">Object</span>.defineProperty(vm, key, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        __get__(key, _data[key])<br>        <span class="hljs-keyword">return</span> _data[key]<br>      &#125;,<br><br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> oldValue = _data[key]<br>        _data[key] = newValue<br>        __set__(key, newValue, oldValue)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reactive<br></code></pre></td></tr></table></figure><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><ol><li><p>路径：/vue/computed</p></li><li><p>思路：用数组保存所有的computed数据，并将计算属性名称挂载在实例上，数据结构为</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">              key(计算属性的名称)<br>对象数组 --&gt;  value(缓存的计算属性返回的值)<br>              dep(计算属性需要更新的变量)<br>              get(计算属性求值的函数)<br></code></pre></td></tr></table></figure></li><li><p>代码</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computed</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.computedData = [];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">addComputed</span>(<span class="hljs-params">vm, computed, key</span>)</span> &#123;<br><span class="hljs-keyword">const</span> descript = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(computed, key);<br><br><span class="hljs-keyword">const</span> descriptFn = descript.value.get ? descript.value.get : descript.value,<br>get = descriptFn.bind(vm),<br>value = get(),<br>dep = <span class="hljs-built_in">this</span>._collectDep(descriptFn);<br><br>    <span class="hljs-built_in">this</span>.computedData.push(&#123;<br>      get,<br>      key,<br>      value,<br>      dep<br>    &#125;)<br><br>    <span class="hljs-keyword">let</span> _data = <span class="hljs-built_in">this</span>.computedData.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.key == key)<br><br>    <span class="hljs-built_in">Object</span>.defineProperty(vm, key, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> _data.value<br>      &#125;<br>    &#125;)<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">key, cb</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.computedData.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>      <span class="hljs-keyword">let</span> _key = item.dep.find(<span class="hljs-function"><span class="hljs-params">itemKey</span> =&gt;</span> itemKey == key)<br>      <span class="hljs-keyword">if</span>(_key)&#123;<br>        item.value = item.get()<br>        cb &amp;&amp; cb()<br>      &#125;<br>    &#125;)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">_computedDataPush</span>(<span class="hljs-params">options</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.computedData.push(options)<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-title">_collectDep</span>(<span class="hljs-params">fn</span>)</span> &#123;<br><span class="hljs-keyword">let</span> match = fn.toString().match(<span class="hljs-regexp">/this\.([a-zA-Z_]+)/g</span>);<br><span class="hljs-keyword">return</span> match.map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>])<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Computed;<br><br></code></pre></td></tr></table></figure><h4 id="watch监听器"><a href="#watch监听器" class="headerlink" title="watch监听器"></a>watch监听器</h4><ol><li><p>路径：/vue/watch</p></li><li><p>思路:用数组保存所有watch数据，数据结构为</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">              key(监听器的名称)<br>对象数组 --&gt;   watchFn(监听变化执行的函数)<br></code></pre></td></tr></table></figure></li><li><p>代码：</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData = []<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">addWatcher</span>(<span class="hljs-params">vm, watch, key</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>._addWatchData(vm, key, watch[key])<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">key, newValue, oldValue</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(item.key == key)&#123;<br>        item.watchFn(newValue, oldValue)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">_addWatchData</span>(<span class="hljs-params">vm, key, watchFn</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData.push(&#123;<br>      key,<br>      <span class="hljs-attr">watchFn</span>:watchFn.bind(vm)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Watcher<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>灵活使用回调函数</li><li>object.definproperty的使用</li><li>computed解决方案</li><li>尽可能为以后扩展留回调</li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2019/11/03/Lazy-loading-of-images/"/>
      <url>/2019/11/03/Lazy-loading-of-images/</url>
      
        <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>在一些图片量比较大的场景（电商首页，小程序首页等），如果我们打开页面时就加载所有的图片，那势必会导致页面的卡顿以及白屏，给用户不好的体验，导致用户流失。</p></li><li><p>但是我们仔细想一下，用户真的需要我们显示所有图片一起展示吗？其实并不是，用户看到的只是浏览器可视区域的内容。所以从这个情况我们可以做一些优化，只显示用户可视区域内的图片，当用户触发滚动的瞬间再去请求显示给用户。</p></li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><h4 id="planA"><a href="#planA" class="headerlink" title="planA"></a>planA</h4><p>监听到scroll事件后，调用目标元素的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。计算目标元素的offsettop、屏幕高度、滚动条的高度之间的值确定元素是否显示在页面中</p><ul><li><p>img 标签有自定义属性 data-src</p></li><li><p>首屏展示可视区域内的图片 src 值 替换为 data-src</p></li><li><p>滚动出现在可视区域的图片即时展示 （重复第二步）</p></li><li><p>利用scroll事件函数判断目标元素是否显示在页面中（getBoundingClientRect()获取返回元素的大小及其相对于视口的位置）</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">viewHeight = <span class="hljs-built_in">window</span>.innerHeight<br>imgs = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;imgs&quot;</span>))<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 运用闭包 count 进行计数 避免已显示的图片重复参与循环</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = count; i &lt; imgs.length; i++) &#123;<br>            <span class="hljs-comment">// getBoundingClientRect()获取返回元素的大小及其相对于视口的位置</span><br>            <span class="hljs-comment">// 获取第i张图片是否在可视区域</span><br>            <span class="hljs-keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top<br>            <span class="hljs-keyword">if</span> (distance &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 图片在可视区域时设置图片的src 为 当前元素 data-src</span><br>                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>                imgs[i].removeAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>                <span class="hljs-comment">// 图片已被显示，下次从count + 1 张开始检查是否在可视区域</span><br>                count += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 添加滚动事件触发加载</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyLoad, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>至此我们已经初步完成了我们的懒加载，但是我们大家都知道，scroll这个事件实在太容易被触发了，用户一滚动鼠标就会触发很多次，如果一直滚势必会导致重复触发执行我们的事件，这也会导致我们的性能急剧下降，所以这就引出了我们的混合体 防抖节流 来优化我们的性能。</p><ul><li><p><strong>节流</strong><br>比如mouseover，resize这种事件，每当有变化的时候，就会触发一次函数，这样很浪费资源。就比如一个持续流水的水龙头，水龙头开到最大的时候很浪费水资源，将水龙头开得小一点，让他每隔200毫秒流出一滴水，这样能源源不断的流出水而又不浪费。而节流就是每隔n的时间调用一次函数，而不是一触发事件就调用一次，这样就会减少资源浪费。</p></li><li><p><strong>防抖</strong><br>A和B说话，A一直说，当A持续说了一段时间的话后停止讲话，过了10秒之后，我们判定A讲完了，B开始回答A的话；如果10秒内A又继续讲话，那么我们判定A没讲完，B不响应，等A再次停止后，我们再次计算停止的时间，如果超过10秒B响应，如果没有则B不响应。</p></li><li><p><strong>节流与防抖的区别</strong><br>节流与防抖的前提都是某个行为持续地触发，不同之处只要判断是要优化到减少它的执行次数还是只执行一次就行。</p></li></ul><h4 id="planB"><a href="#planB" class="headerlink" title="planB"></a>planB</h4><p>利用IntersectionObserver实现<br><strong>IntersectionObserver使用方法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(callback, option);<br></code></pre></td></tr></table></figure><p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 开始观察</span><br>io.observe(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>));<br><br><span class="hljs-comment">// 停止观察</span><br>io.unobserve(element);<br><br><span class="hljs-comment">// 关闭观察器</span><br>io.disconnect();<br></code></pre></td></tr></table></figure><p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">io.observe(elementA);<br>io.observe(elementB);<br></code></pre></td></tr></table></figure><h5 id="callback-参数"><a href="#callback-参数" class="headerlink" title="callback 参数"></a>callback 参数</h5><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<br>  <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(entries);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</p><h5 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h5><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<br>  time: <span class="hljs-number">1875.699999988079</span>,<br>  rootBounds: DOMRectReadOnly &#123;<br>    bottom: <span class="hljs-number">920</span>,<br>    height: <span class="hljs-number">1024</span>,<br>    left: <span class="hljs-number">0</span>,<br>    right: <span class="hljs-number">1024</span>,<br>    top: <span class="hljs-number">0</span>,<br>    width: <span class="hljs-number">920</span><br>  &#125;,<br>  boundingClientRect: DOMRectReadOnly &#123;<br>     <span class="hljs-comment">// ...</span><br>  &#125;,<br>  intersectionRect: DOMRectReadOnly &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  intersectionRatio: <span class="hljs-number">0.54</span>,<br>  target: element<br>&#125;<br></code></pre></td></tr></table></figure><p>每个属性的含义如下。</p><ul><li>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li>target：被观察的目标元素，是一个 DOM 节点对象</li><li>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li><li>boundingClientRect：目标元素的矩形区域的信息</li><li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li><li>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0</li></ul><h5 id="Option-对象"><a href="#Option-对象" class="headerlink" title="Option 对象"></a>Option 对象</h5><ol><li><p>threshold<br> threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> IntersectionObserver(<br>  <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;, <br>  &#123;<br>    <span class="hljs-attr">threshold</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1</span>]<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p> 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p></li><li><p>root 属性和 rootMargin 属性<br> 很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性</p><p> IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> opts = &#123; <br>  <span class="hljs-attr">root</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>),<br>  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;500px 0px&quot;</span> <br>&#125;;<br><br><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<br>  callback,<br>  opts<br>);<br></code></pre></td></tr></table></figure><p> 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。</p><p> 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p></li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="!!!注意点"></a>!!!<strong>注意点</strong></h5><ul><li><p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。</p></li><li><p>规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p></li></ul><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.JQ-VhVrsScl0rLNrPtMlcQHaE8?w=260&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7&quot;</span>,<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th?id=OIP-C.M9CUntHQGPvSO5JkAn5Y4AHaFA&amp;w=140&amp;h=100&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2&quot;</span>,<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th?id=OIP-C.xsA-3qUw6cqmd8nRfxk6TQHaEK&amp;w=168&amp;h=100&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2&quot;</span>,<br>];<br><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">ios</span>) =&gt;</span> &#123;<br>  ios.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item.intersectionRatio) &#123;<br>      <span class="hljs-keyword">var</span> contain = item.target,<br>          image = <span class="hljs-keyword">new</span> Image();<br>      image.src = arr[n % <span class="hljs-number">3</span>];<br>      image.style.width = <span class="hljs-string">&quot;100%&quot;</span>;<br>      n++;<br>      image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        contain.appendChild(image);<br>        io.unobserve(contain);<br>      &#125;;<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">let</span> lis = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;test&quot;</span>);<br><br><span class="hljs-built_in">Array</span>.from(lis).forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  io.observe(item);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端设计思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础知识</title>
      <link href="/2019/04/05/javascript-foundation/"/>
      <url>/2019/04/05/javascript-foundation/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型和语法"><a href="#数据类型和语法" class="headerlink" title="数据类型和语法"></a>数据类型和语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>七种基本数据类型<ol><li>布尔值(Boolean),有两个值分别为：<code>true</code>和<code>false</code></li><li>null,一个表明null值的关键字，JavaScript 是大小写敏感的，因此null 与 Null、NULL或变体完全不同。</li><li>undefined, 和null一样的特殊关键字，undefined表示变量未赋值时的属性 </li><li>数字（Number），整数或浮点数，例如： 42 或者 3.14159。</li><li>任意精度的整数 (BigInt) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li><li>字符串（String），字符串是一串表示文本值的字符序列，例如：”Howdy” 。</li><li>代表（Symbol） ( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。</li></ol></li><li>对象(Object)</li></ul><h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><ol><li><p>在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">x = <span class="hljs-string">&quot;The answer is &quot;</span> + <span class="hljs-number">42</span> <span class="hljs-comment">// &quot;The answer is 42&quot;</span><br>y = <span class="hljs-number">42</span> + <span class="hljs-string">&quot; is the answer&quot;</span> <span class="hljs-comment">// &quot;42 is the answer&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;37&quot;</span> - <span class="hljs-number">7</span> <span class="hljs-comment">// 30</span><br><span class="hljs-string">&quot;37&quot;</span> + <span class="hljs-number">7</span> <span class="hljs-comment">// &quot;377&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>parseInt 方法只能返回整数，所以使用它会丢失小数部分。另外，调用 parseInt 时最好总是带上进制(radix) 参数，这个参数用于指定使用哪一种进制。将字符串转换为数字的另一种方法是使用一元加法运算符。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66a&quot;</span>) <span class="hljs-comment">// 66</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 54 以8进制66解析为10进制的54</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br>(<span class="hljs-number">54</span>).toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// 66 10进制的54解析为8进制的66</span><br><span class="hljs-string">&quot;54&quot;</span>.toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// 54 字符串则不会进制转换</span><br><br><span class="hljs-comment">// 一元加法运算符字符串转数字</span><br><span class="hljs-string">&quot;1.1&quot;</span> + <span class="hljs-string">&quot;1.1&quot;</span> = <span class="hljs-string">&quot;1.11.1&quot;</span><br>(+<span class="hljs-string">&quot;1.1&quot;</span>) + (+<span class="hljs-string">&quot;1.1&quot;</span>) = <span class="hljs-number">2.2</span><br><span class="hljs-comment">// 注意：加入括号为清楚起见，不是必需的。</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="流程控制与错误处理"><a href="#流程控制与错误处理" class="headerlink" title="流程控制与错误处理"></a>流程控制与错误处理</h2><h3 id="if…else…语句"><a href="#if…else…语句" class="headerlink" title="if…else…语句"></a>if…else…语句</h3><ol><li><p>if 条件错误的值（也被叫做Falsy值）</p><ul><li>false</li><li>undefined</li><li>null</li><li>0</li><li>NaN</li><li>空字符串（””） </li></ul><p> <em><strong>注意不报括（”   “中间有空格）当传递给条件语句所有其他的值，包括所有对象会被计算为真 。</strong></em></p></li><li><p>请不要混淆原始的布尔值true和false 与 Boolean对象的真和假。例如：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//结果视为真</span><br><span class="hljs-keyword">if</span> (b == <span class="hljs-literal">true</span>) <span class="hljs-comment">// 结果视为假</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="try…catch…finally…-语句"><a href="#try…catch…finally…-语句" class="headerlink" title="try…catch…finally… 语句"></a>try…catch…finally… 语句</h3><ol><li><p>简介</p><p> 如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。</p></li><li><p>catch 块<br> 可以用这个标识符来获取抛出的异常信息。在插入throw块时JavaScript创建这个标识符；标识符只存在于catch块的存续期间里；当catch块执行完成时，标识符不再可用。</p></li><li><p>finally块<br>finally块包含了在try和catch块完成后、下面接着try…catch的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(Array对象)</title>
      <link href="/2018/10/06/javascript-array/"/>
      <url>/2018/10/06/javascript-array/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-描述"><a href="#Array-描述" class="headerlink" title="Array 描述"></a>Array 描述</h3><p><code>JavaScript</code> 的 <code>Array</code> 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。<br>数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。</p><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ol><li><p><strong>数组forEach</strong></p><p> Array.prototype.forEach(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: undefined</li></ul><p> <strong>数组遍历</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>     <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>     <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>     <span class="hljs-keyword">var</span> thisArg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>         cb.apply(thisArg,[_arr[i],i,_arr])<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组map</strong></p><p> Array.prototype.map(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 返回由原数组映射出来的新数组，该数组中的每个元素是调用一次提供的函数后的返回值。</li></ul><p> <strong>数组map</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">var</span> result = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i &lt; _len ; i ++)&#123;<br>        result.push(cb.apply( _arg, [_arr[i], i, _arr]))<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>数组filter</strong></p><p> Array.prototype.filter(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 返回由原数组映射出来的新数组，该数组中的每个元素是调用一次提供的函数后的返回值是否为true；如果为true则将该项添加至新数组，反之不添加。</li></ul><p> <strong>数组filter</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">var</span> result = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        cb.apply(_arg, [_arr[i], i, _arr]) ? result.push(_arr[i]) : <span class="hljs-string">&quot;&quot;</span><br>            <br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组every</strong></p><p> Array.prototype.every(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 调用一次提供的函数后的返回值，如果全为真则返回true否则返回false</li></ul><p> <strong>数组every</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myEvery = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(cb.apply(_arg, [_arr[i], i, _arr]))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组some</strong></p><p> Array.prototype.some(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 调用一次提供的函数后的返回值，如果有一个为真则返回true否则返回false</li></ul><p> <strong>数组some</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.mySome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!cb.apply(_arg, [_arr[i], i, _arr]))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组reduce</strong></p><p> Array.prototype.reduce(callback,initialValue)</p><ul><li>callback回调函数：参数包括(accumulator, currentValue ,index, array)</li><li>initialValue: accumulator初始值不传的话默认为数组第一项; 在没有初始值的空数组上调用 <code>reduce</code> 将报错。</li></ul><p> <strong>数组reduce</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,<br>        _len = <span class="hljs-built_in">this</span>.length,<br>        flag = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>,<br>        _initIndex = flag ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,<br>        _initialValue =  flag ?  _arr[<span class="hljs-number">0</span>] : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = _initIndex; i &lt; _len; i ++)&#123;<br>        _initialValue = cb(_initialValue, _arr[i], i, _arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _initialValue<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组reduceRight</strong></p><p> Array.prototype.reduceRight(callback,initialValue)</p><ul><li>callback回调函数：参数包括(accumulator, currentValue ,index, array)</li><li>initialValue: accumulator初始值不传的话默认为数组第一项; 在没有初始值的空数组上调用 <code>reduceRight</code> 将报错。</li></ul><p> <strong>数组reduceRight</strong>重写</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduceRight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span><br>    <span class="hljs-keyword">var</span> _initIndex = flag ? _len - <span class="hljs-number">2</span>  : _len - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> _initialValue =  flag ?  _arr[_len - <span class="hljs-number">1</span>] : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = _initIndex; i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>        _initialValue = cb(_initialValue, _arr[i], i, _arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _initialValue<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(promise)</title>
      <link href="/2018/09/01/javascript-promise/"/>
      <url>/2018/09/01/javascript-promise/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h3><p>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。<br>存在意义：<strong>异步问题同步化解决方案</strong></p><h3 id="Promise-描述"><a href="#Promise-描述" class="headerlink" title="Promise 描述"></a>Promise 描述</h3><p>一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <code>promise</code>，以便在未来某个时候把值交给使用者。<br>一个 Promise 必然处于以下几种状态之一：</p><ul><li>待定（<code>pending</code>）: 初始状态，既没有被兑现，也没有被拒绝。</li><li>已兑现（<code>fulfilled</code>）: 意味着操作成功完成。</li><li>已拒绝（<code>rejected</code>）: 意味着操作失败。</li></ul><p>待定状态的 Promise 对象要么会通过一个值被兑现（<em>fulfilled</em>），要么会通过一个原因（错误）被拒绝（<em>rejected</em>）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。<br>因为 <code>Promise.prototype.then</code> 和  <code>Promise.prototype.catch</code> 方法返回的是 <code>promise</code>， 所以它们可以被链式调用。</p><h3 id="Promise-运行流程"><a href="#Promise-运行流程" class="headerlink" title="Promise 运行流程"></a>Promise 运行流程</h3><ol><li>executor会立即执行（同步执行）</li><li>然后将任务储存在微任务中</li><li>等待 构造函数中的 <code>resolve</code> 或 <code>reject</code> 执行，只有第一次执行有效，多次调用没有任何作用,如果一直<strong>没调用</strong>则永远不会触发 <code>then</code> 或者 <code>catch</code></li><li>等主线程执行完成，事件循环机制(<code>Event Loop</code>)从微任务中查看状态（有可执行的微任务调出来运行 <code>then</code> 或者 <code>catch</code> ）</li><li><code>then</code> 和 <code>catch</code> 会返回一个新的 <code>promise</code> 所以可以被链式调用且下一个 <code>then</code> 或者 <code>catch</code>传值为上一个 <code>then</code> 或者 <code>catch</code>函数的返回值。</li><li><code>catch</code> 类似 <code>switch-case</code>的 <code>default</code> 可以用来兜底</li></ol><p><strong>宏任务与微任务</strong></p><ul><li>宏任务（任务队列）：setTimeout产生的队列为宏任务</li><li>微任务（任务队列）：promise产生的队列为微任务</li></ul><blockquote><p>同一时间微任务的优先级会大于微任务</p><p>微任务 &gt; DOM渲染 &gt; 宏任务</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;executor&quot;</span>); r()&#125;)<br><span class="hljs-keyword">let</span> con = <span class="hljs-string">&quot;测试&quot;</span>;<br><span class="hljs-built_in">document</span>.write(con);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2&quot;</span>),<span class="hljs-number">0</span>)<br>p.then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;p3&quot;</span>))<br><span class="hljs-comment">// 执行顺序 executor =&gt; 1 =&gt; p3 =&gt; dom渲染 =&gt; s2</span><br></code></pre></td></tr></table></figure><h3 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a>Promise.all([])</h4><p>该方法接收一个Promise数组返回一个Promise，只有<strong>当该数组中的所有Promise完成</strong>后才会由pendding状态变为resolve<strong>执行then</strong>里面的回调函数，若数组中有<strong>任意一个或多个promise被拒绝</strong>则会执行<strong>失败回调</strong>，catch方法会捕获到首个被执行的 reject函数。该方法获得的成功结果的数组里面的数据顺序和接收到的promise数组顺序是一致的。</p><h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any([])"></a>Promise.any([])</h4><p>当传入的promise数组中有<strong>任意一个完成时就会终止</strong>，会忽略到所有被拒绝掉的promise，直到第一个promise完成。若传入<strong>所有的promise被拒绝则会执行拒绝回调</strong>。</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([])"></a>Promise.race([])</h4><p>当promise数组中任意一个promise被拒绝或者成功，则会<strong>采用第一个promise作为他的返回值</strong>。若为成功的执行then，若失败则执行catch。</p><h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled([])"></a>Promise.allSettled([])</h4><p>当给定的promise数组中的所有promise被拒绝后会返回一个拒绝的promise数组，与[]一一对应。<br>一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，未决议的 Promise将被异步完成。那时，所返回的 <strong>promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。</strong><br>对于<strong>每个结果对象，都有一个 status 字符串</strong>。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。</p>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(this指向)</title>
      <link href="/2018/07/01/javascript-this/"/>
      <url>/2018/07/01/javascript-this/</url>
      
        <content type="html"><![CDATA[<h3 id="js-的默认-this-指向"><a href="#js-的默认-this-指向" class="headerlink" title="js 的默认 this 指向"></a>js 的默认 this 指向</h3><p>在浏览器中非严格模式 this 默认指向 <code>window</code> 或者 <code>self</code> 或者 <code>frames</code> 或者 <code>globalThis</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span> === self === frames === globalThis;<br></code></pre></td></tr></table></figure><p>在 nodejs 中非严格模式 this 默认指向 <code>global</code> 或者 <code>globalThis</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">global</span> === globalThis;<br></code></pre></td></tr></table></figure><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在浏览器中, window 对象同时也是全局对象：</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>); <span class="hljs-comment">// true</span><br><br>a = <span class="hljs-number">37</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 37</span><br><br><span class="hljs-built_in">this</span>.b = <span class="hljs-string">&quot;MDN&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.b); <span class="hljs-comment">// &quot;MDN&quot;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// &quot;MDN&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-built_in">this</span>.d = <span class="hljs-string">&quot;MDN&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.d); <span class="hljs-comment">// &quot;MDN&quot;</span><br><span class="hljs-built_in">console</span>.log(d); <span class="hljs-comment">// &quot;MDN&quot;</span><br><br>c = <span class="hljs-number">37</span>; <span class="hljs-comment">// 会报错 Uncaught ReferenceError: c is not defined</span><br></code></pre></td></tr></table></figure><blockquote><p>特别案例：类里面的方法会默认开启严格模式</p></blockquote><h3 id="JavaScript-的-this-原理"><a href="#JavaScript-的-this-原理" class="headerlink" title="JavaScript 的 this 原理"></a>JavaScript 的 this 原理</h3><h4 id="1、问题的由来"><a href="#1、问题的由来" class="headerlink" title="1、问题的由来"></a>1、问题的由来</h4><p>学懂 JavaScript 语言，一个标志就是理解下面两种写法，可能有不一样的结果。</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br> &#125;;<br><br><span class="hljs-keyword">var</span> foo = obj.foo;<br><br><span class="hljs-comment">// 写法一</span><br>obj.foo();<br><br><span class="hljs-comment">// 写法二</span><br>foo();<br></code></pre></td></tr></table></figure><p>上面代码中，虽然 obj.foo 和 foo 指向同一个函数，但是执行结果可能不一样。请看下面的例子。</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>     <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.bar);<br>     &#125;,<br>     <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span>,<br> &#125;;<br><br><span class="hljs-keyword">var</span> foo = obj.foo;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br>obj.foo(); <span class="hljs-comment">// 1</span><br>foo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="2、内存的数据结构"><a href="#2、内存的数据结构" class="headerlink" title="2、内存的数据结构"></a>2、内存的数据结构</h4><p>JavaScript 语言之所以有this的设计，跟内存里面的数据结构有关系。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>:  <span class="hljs-number">5</span> &#125;;<br></code></pre></td></tr></table></figure><p>上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。</p><p><img src="/image/md-image/%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"><br>也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。</p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。<br><img src="/image/md-image/obj%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    [[value]]: <span class="hljs-number">5</span><br>    [[writable]]: <span class="hljs-literal">true</span><br>    [[enumerable]]: <span class="hljs-literal">true</span><br>    [[configurable]]: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，foo属性的值保存在属性描述对象的value属性里面。</p><h4 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h4><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125; &#125;;<br></code></pre></td></tr></table></figure><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。<br><img src="/image/md-image/func%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    [[value]]: 函数的地址<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">f</span>: f &#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f()<br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f()<br></code></pre></td></tr></table></figure><h4 id="4、环境变量"><a href="#4、环境变量" class="headerlink" title="4、环境变量"></a>4、环境变量</h4><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">f</span>: f,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数f在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>。</p><p><img src="/image/md-image/func1.png" alt="函数调用" title="函数调用内存指向"><br>在obj环境执行，<code>this.x</code>指向<code>obj.x</code>。</p><p><img src="/image/md-image/func2.png" alt="函数调用" title="函数调用内存指向"><br>回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。</p><h4 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h4><ol><li><p>function.call(thisArg, arg1, arg2, …)</p><ul><li>thisArg: 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</li><li>arg1, arg2, …: 指定的参数列表</li></ul></li><li><p>function.apply(thisArg, [argsArray])</p><ul><li>this.arg: 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</li><li>argsArray: 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li></ul></li><li><p>function.bind(thisArg,arg1, arg2, …)</p><ul><li>thisArg: 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数<br>（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg</li><li>arg1, arg2, …: 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li><li>bind的多次绑定只有第一次是有效的且不会执行函数</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>this 的指向 是在执行上下文时才确定的, 并且确定后不可更改；</li><li>this 指向 <strong>其执行上下文的环境对象</strong>;</li><li>this简单判断依据（<strong>谁调用则this指向谁</strong>）</li><li><strong>严格</strong>模式下全局调用函数this不默认指向window而是undefined</li><li><strong>类</strong>中定义的方法中默认会开启严格模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google js 规范</title>
      <link href="/2018/06/03/specification/"/>
      <url>/2018/06/03/specification/</url>
      
        <content type="html"><![CDATA[<h4 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h4><ul><li>文件名必须小写但是可以含有（_或者-）但是不能含有其他的符号</li><li>源文件以 UTF-8 编码</li><li>制表符不用于缩进</li><li>对于任何具有特殊转义序列（&#39;、&quot;、\、\b、\f、\n、\r、\t、\v）的字符，将使用该序列而不是相应的数字转义（例如\x0a、\u000a 或 \u{a}）。从不使用传统的八进制转义。</li><li>对于剩余的非 ASCII 字符，使用实际的 Unicode 字符（例如 ∞）或等效的十六进制或 Unicode 转义符（例如 \u221e），仅取决于哪个使代码更易于阅读和理解。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 最好的方式，即使没有注释也很清晰</span><br><span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;μs&#x27;</span>;<br><span class="hljs-comment">// 允许（后面有注释，可以清楚表达意思）：但不必要，因为 μ 是可打印字符。</span><br><span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;\u03bcs&#x27;</span>; <span class="hljs-comment">// &#x27;μs&#x27;</span><br><span class="hljs-comment">// 很好的方式，为了清楚起见，对不可打印的字符使用转义符，并带有注释。</span><br><span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content; <span class="hljs-comment">//content 为不可打印字符，预先添加字节顺序标记。</span><br><span class="hljs-comment">// 最差的方式，没有注释，读者不知道或者不能清晰的明白这是个什么</span><br><span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;\u03bcs&#x27;</span>;<br><span class="hljs-comment">// 永远不要因为担心某些程序可能无法正确处理非 ASCII 字符而使代码的可读性降低。</span><br></code></pre></td></tr></table></figure><h4 id="导入文件规范"><a href="#导入文件规范" class="headerlink" title="导入文件规范"></a>导入文件规范</h4><ul><li>.js 文件扩展名在导入路径中不是可选的，必须始终包含在内。这样代码更清晰</li><li>不要多次导入同一个文件。这会使确定文件的总导入变得困难（同一文件下的导入应该统一在一起）</li><li>仅在要在模块外部使用时才导出。未导出的模块本地符号未声明为 @private，它们的名称也不以下划线结尾。导出和模块本地符号没有规定的顺序。</li><li>不要使用默认导出。导入模块必须为这些值命名，这会导致模块间命名不一致。也可以达到按需加载</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 别使用默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123; ... &#125; <span class="hljs-comment">// 不好的!</span><br><br><span class="hljs-comment">// 使用命名导出:</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123; ... &#125; <span class="hljs-comment">// 推荐</span><br><br><span class="hljs-comment">// 替代样式命名导出:</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123; ... &#125;<br><br><span class="hljs-keyword">export</span> &#123;Foo&#125;; <span class="hljs-comment">// 推荐</span><br></code></pre></td></tr></table></figure><ul><li>不要为了命名空间而导出带有静态方法或属性的容器类或对象。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不好：Container 是一个导出类，只有静态方法和字段。</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;<br>  <span class="hljs-comment">/** <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span> </span>*/</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@const <span class="hljs-type">&#123;number&#125;</span> </span>*/</span><br>Container.FOO = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 好的方式：直接单独导出需要常量或者函数</span><br><span class="hljs-comment">/** <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span> </span>*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">/** number */</span> FOO = <span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><ul><li>不得在模块初始化之外更改导出的变量。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不好的: foo 和 mutateFoo 都被导出和变异</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-comment">/** number */</span> foo = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Mutates foo.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutateFoo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ++foo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function(number): number&#125;</span> <span class="hljs-variable">newMutateFoo</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMutateFoo</span>(<span class="hljs-params">newMutateFoo</span>) </span>&#123;<br>  <span class="hljs-comment">// 导出的类和函数可以变异!</span><br>  mutateFoo = <span class="hljs-function">() =&gt;</span> &#123;<br>    foo = newMutateFoo(foo);<br>  &#125;;<br>&#125;<br><br>----------------------------------------------------<br><span class="hljs-comment">// 好的方法：给foo一个getter函数，给mutateFooFunc一个包装</span><br><span class="hljs-keyword">let</span> <span class="hljs-comment">/** number */</span> foo = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-comment">/** function(number): number */</span> mutateFooFunc = <span class="hljs-function"><span class="hljs-params">foo</span> =&gt;</span> foo + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span> </span>*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFoo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> foo;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutateFoo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  foo = mutateFooFunc(foo);<br>&#125;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@param <span class="hljs-type">&#123;function(number): number&#125;</span> </span>mutateFoo */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMutateFoo</span>(<span class="hljs-params">mutateFoo</span>) </span>&#123;<br>  mutateFooFunc = mutateFoo;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><code>export from</code> 语句不能换行</li><li>不要在模块中创建循环比如（在a模块中引入b，又在b模块中引入a），即使ECMAScript允许这样的语法</li><li>一个<strong>没有else</strong>且<strong>语句可以放在一行</strong>的if ，当它提高可读性时，可以保留在没有大括号的一行中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
