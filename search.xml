<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3.0-依赖收集</title>
      <link href="/2022/10/05/js-vue3.0/"/>
      <url>/2022/10/05/js-vue3.0/</url>
      
        <content type="html"><![CDATA[<h2 id="简单实现vue3-0的数据劫持和依赖收集"><a href="#简单实现vue3-0的数据劫持和依赖收集" class="headerlink" title="简单实现vue3.0的数据劫持和依赖收集"></a>简单实现vue3.0的数据劫持和依赖收集</h2><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul><li>index.html</li><li>js<ul><li>index.js (使用对应函数)</li><li>collect<ul><li>index.js (导出响应的函数)</li><li>reactive.js (数据劫持)</li><li>effact.js (watch等副作用函数)</li><li>Dep.js  (依赖收集)</li><li>ComputedRef.js (计算属性数据劫持)</li></ul></li></ul></li></ul><h4 id="实现内容"><a href="#实现内容" class="headerlink" title="实现内容"></a>实现内容</h4><p>实现<code>js/index.js</code>中能正常使用各个函数并保证逻辑正确</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/index.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  reactive,<br>  watchEffect,<br>  watch,<br>  computed<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./collect/index.js&quot;</span><br><br><span class="hljs-keyword">const</span> aBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#aBtn&quot;</span>);<br><span class="hljs-keyword">const</span> cBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#cBtn&quot;</span>);<br><br><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> res = computed(<span class="hljs-function">() =&gt;</span> state.a + state.b.c);<br><br><br>aBtn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  state.a = <span class="hljs-number">100</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;computed state.a + state.b.c&#x27;</span>,res);<br>&#125;, <span class="hljs-literal">false</span>)<br><br>cBtn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  state.b.c = <span class="hljs-number">200</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;computed state.a + state.b.c&#x27;</span>,res);<br>&#125;, <span class="hljs-literal">false</span>)<br><br>watchEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;watchEffect state.a&quot;</span>, state.a);<br>&#125;)<br><br>watchEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;watchEffect state.b.c&quot;</span>, state.b.c);<br>&#125;)<br><br>watch(<span class="hljs-function">() =&gt;</span> state.a, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;watch state.a&quot;</span>,newValue, oldValue)<br>&#125;)<br><br>watch(<span class="hljs-function">() =&gt;</span> state.b.c, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;watch state.b.c&quot;</span>, newValue, oldValue);<br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>使用proxy实现数据劫持</li><li>在获取数据时进行依赖收集</li><li>在设置数据时进行广播</li></ol><h5 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h5><p>在<code>js/collect/reactive.js</code>中实现数据劫持</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/collect/reactive.js</span><br><span class="hljs-keyword">import</span> Dep <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Dep&quot;</span> <span class="hljs-comment">// 依赖收集，类似发布订阅</span><br><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span> (<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, key</span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Reflect</span>.get(target, key)<br>      dep.collect(target, key) <span class="hljs-comment">// 依赖收集</span><br>      <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> ? reactive(value) : value <span class="hljs-comment">// 递归数据劫持</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, value</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> oldValue = target[key]<br>      <span class="hljs-keyword">const</span> returnValue = <span class="hljs-built_in">Reflect</span>.set(target, key, value)<br>      dep.notify(target, key, value, oldValue) <span class="hljs-comment">// 广播</span><br>      <span class="hljs-keyword">return</span> returnValue<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="副作用函数"><a href="#副作用函数" class="headerlink" title="副作用函数"></a>副作用函数</h4><p>在<code>js/collect/effect.js</code>中实现副作用函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/collect/effect.js</span><br><br><span class="hljs-keyword">import</span> Dep <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Dep&quot;</span><br><span class="hljs-keyword">import</span> ComputedRef <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./computedRef&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchEffect</span>(<span class="hljs-params">callBack</span>) </span>&#123;<br>  Dep.effectDB = callBack; <span class="hljs-comment">// 利用静态属性传递对应的回调函数</span><br>  callBack() <span class="hljs-comment">// 函数调用，如果用到数据劫持的数据会触发get</span><br>  Dep.effectDB = <span class="hljs-literal">null</span> <span class="hljs-comment">// 收集完成后重值为null</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watch</span>(<span class="hljs-params">fn, callback</span>) </span>&#123;<br>  Dep.effectDB = callback; <span class="hljs-comment">// 利用静态属性传递对应的回调函数</span><br>  fn() <span class="hljs-comment">// 函数调用，如果用到数据劫持的数据会触发get</span><br>  Dep.effectDB = <span class="hljs-literal">null</span> <span class="hljs-comment">// 收集完成后重值为null</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computed</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  Dep.effectDB = callback; <span class="hljs-comment">// 利用静态属性传递对应的回调函数</span><br>  <span class="hljs-keyword">const</span> value = callback() <span class="hljs-comment">// 函数调用，如果用到数据劫持的数据会触发get</span><br>  <span class="hljs-keyword">const</span> computedRef = <span class="hljs-keyword">new</span> ComputedRef (value) <span class="hljs-comment">// 对数据进行包装</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(callback, <span class="hljs-string">&#x27;computedRef&#x27;</span>, &#123; <span class="hljs-comment">// 设置一个不可变不可配置不可枚举的参数来识别是否需要获取函数对应的值</span><br>    <span class="hljs-attr">value</span>: computedRef <br>  &#125;)<br>  Dep.effectDB = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 收集完成后重值为null</span><br>  <span class="hljs-keyword">return</span> computedRef <span class="hljs-comment">//返回值并且和callback的computedRef保持统一引用值，callback上的computedRef变化，返回值跟着变化</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h4><p>在<code>js/collect/Dep.js</code>中实现依赖收集</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/collect/Dep.js</span><br><br><span class="hljs-comment">// 收集保存逻辑</span><br><span class="hljs-built_in">WeakMap</span> &#123;<br>  target ----&gt; <span class="hljs-built_in">Map</span><br>  ...<br>    <span class="hljs-built_in">Map</span> &#123;<br>      key ----&gt; <span class="hljs-built_in">Set</span><br>      ...<br>        <span class="hljs-built_in">Set</span> &#123;<br>          [callback1, callback2, ...]<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> effectDB = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.effectMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>() <span class="hljs-comment">// 创建顶层的WeakMap</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">collect</span>(<span class="hljs-params">target, key</span>)</span> &#123; <span class="hljs-comment">// 依赖收集</span><br>    <span class="hljs-keyword">if</span>(Dep.effectDB === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//如果没有回调函数则直接return</span><br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.effectMap.get(target)) &#123;  <span class="hljs-comment">// 如果没有创建target对应的Map则创建</span><br>      <span class="hljs-built_in">this</span>.effectMap.set(target, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>())<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.effectMap.get(target).get(key))&#123; <span class="hljs-comment">// 如果没有key对应的Set则创建</span><br>      <span class="hljs-built_in">this</span>.effectMap.get(target).set(key, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>())<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.effectMap.get(target).get(key).add(Dep.effectDB) <span class="hljs-comment">//给Set添加对应的callback</span><br><br><br>      <br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params">target, key, newValue, oldValue</span>)</span> &#123;  <span class="hljs-comment">// 广播</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.effectMap?.get(target)?.get(key)) &#123;  <span class="hljs-comment">// 如果拥有对应的callbackSet则依次执行</span><br>      <span class="hljs-built_in">this</span>.effectMap.get(target).get(key).forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(fn.computedRef) &#123;  <span class="hljs-comment">// 判断是否是computed的回调，如果是则赋值，反之则执行</span><br>          fn.computedRef.value = fn(newValue, oldValue) <br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          fn(newValue, oldValue)<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="computedRef-劫持"><a href="#computedRef-劫持" class="headerlink" title="computedRef 劫持"></a>computedRef 劫持</h4><p>在<code>js/collect/computedRef.js</code>中实现依赖收集</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/collect/computedRef.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputedRef</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">data</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._value = data<br>  &#125;<br><br>  get value () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._value<br>  &#125;<br><br>  set value (newValue) &#123;<br>    <span class="hljs-built_in">this</span>._value = newValue<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数导出"><a href="#函数导出" class="headerlink" title="函数导出"></a>函数导出</h4><p>在<code>js/collect/index.js</code>中统一导出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// js/collect/index.js</span><br><span class="hljs-keyword">export</span> &#123;<br>  reactive<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Reactive.js&quot;</span><br><br><span class="hljs-keyword">export</span> &#123;<br>  watchEffect,<br>  watch,<br>  computed<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Effect&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(equal)</title>
      <link href="/2022/04/02/js-equal/"/>
      <url>/2022/04/02/js-equal/</url>
      
        <content type="html"><![CDATA[<h3 id="相等的四种算法"><a href="#相等的四种算法" class="headerlink" title="相等的四种算法"></a>相等的四种算法</h3><ol><li>抽象（非严格）相等比较 (==)</li><li>严格相等比较 (===)</li><li>同值零</li><li>同值: 用于所有其他地方</li></ol><h3 id="JavaScript提供三种不同的值比较操作"><a href="#JavaScript提供三种不同的值比较操作" class="headerlink" title="JavaScript提供三种不同的值比较操作"></a>JavaScript提供三种不同的值比较操作</h3><ol><li>严格相等比较 (也被称作”strict equality”, “identity”, “triple equals”)，使用 === ,</li><li>抽象相等比较 (“loose equality”，”double equals”) ，使用 ==</li><li>以及 Object.is （ECMAScript 2015/ ES6 新特性）</li></ol><h4 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h4><p>全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。如果值为NaN则不相等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">console</span>.log(num === num); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj === obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(str === str); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(num === obj); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(num === str); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === str); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === <span class="hljs-literal">null</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(obj === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="非严格相等"><a href="#非严格相等" class="headerlink" title="非严格相等 =="></a>非严格相等 ==</h3><p>相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。</p><p><img src="/image/equal/equal.jpg" alt="非严格相等判定" title="非严格相等判定"></p><p>ToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。ToPrimitive(A)通过尝试调用 A 的A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">console</span>.log(num == num); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj == obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(str == str); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(num == obj); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(num == str); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj == str); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// both false, except in rare cases</span><br><span class="hljs-built_in">console</span>.log(obj == <span class="hljs-literal">null</span>);<br><span class="hljs-built_in">console</span>.log(obj == <span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure><h4 id="相等比较的模型"><a href="#相等比较的模型" class="headerlink" title="相等比较的模型"></a>相等比较的模型</h4><p><img src="/image/equal/equal.png" alt="相等比较的区别" title="相等比较的区别"></p><h4 id="Object-is重写"><a href="#Object-is重写" class="headerlink" title="Object.is重写"></a>Object.is重写</h4><ol><li><p>利用 Object.is (同值相等) 与严格相等(零值相等)的区别</p><ul><li><code>Object.is(NaN, NaN)</code>的值为<strong>true</strong></li><li><code>Object.is(+0, -0)</code>的值为<strong>false</strong></li><li>全等时<code>NaN === NaN</code>的值为<strong>false</strong></li><li>全等时<code>+0 === -0</code>的值<strong>true</strong></li></ul></li><li><p>利用 <code>1 / +0 === Infinity</code> 并且 <code>1 / -0 === -Infinity</code> 所以 <code>1 / +0 !== 1 / -0</code>;</p></li><li><p>只有 <code>NaN</code> 不等于自身,判断值是不是 <code>NaN</code></p></li><li><p>代码实现</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.myIs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(a === b) &#123;<br>    <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / a === <span class="hljs-number">1</span> / b<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> a !== a &amp;&amp; b !== b<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础库</title>
      <link href="/2022/04/01/python-lib/"/>
      <url>/2022/04/01/python-lib/</url>
      
        <content type="html"><![CDATA[<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ol><li><p>引入json库</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br></code></pre></td></tr></table></figure></li><li><p>json方法</p><ul><li>json.dumps<br>将 Python 对象编码成 JSON 字符串（返回转换后的json字符串）</li></ul> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">json.dumps(obj, skipkeys=<span class="hljs-literal">False</span>, ensure_ascii=<span class="hljs-literal">True</span>, check_circular=<span class="hljs-literal">True</span>, allow_nan=<span class="hljs-literal">True</span>, cls=<span class="hljs-literal">None</span>, indent=<span class="hljs-literal">None</span>, separators=<span class="hljs-literal">None</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>, default=<span class="hljs-literal">None</span>, sort_keys=<span class="hljs-literal">False</span>, **kw)<br><span class="hljs-comment"># obj - 需要修改的 Python 对象</span><br><span class="hljs-comment"># skipkeys - 默认值是 False，如果dict的keys内的数据不是python的基本类型(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key 。</span><br><span class="hljs-comment"># ensure_ascii - 默认输出ASCLL码，如果把这个该成False,就可以输出中文。</span><br><span class="hljs-comment"># check_circular - 如果check_circular为 False ，则跳过对容器类型的循环引用检查，循环引用将导致溢出错误(或更糟的情况)。</span><br><span class="hljs-comment"># allow_nan - 如果allow_nan为假，则ValueError将序列化超出范围的浮点值(nan、inf、-inf)，严格遵守JSON规范，而不是使用JavaScript等价值(nan、Infinity、-Infinity)。</span><br><span class="hljs-comment"># indent - 参数根据数据格式缩进显示，读起来更加清晰。</span><br><span class="hljs-comment"># separators - 是分隔符的意思，参数意思分别为不同dict项之间的分隔符和dict项内key和value之间的分隔符，把：和，后面的空格都除去了。</span><br><span class="hljs-comment"># sort_keys - True是告诉编码器按照字典排序(a到z)输出。如果是字典类型的python对象，就把关键字按照字典排序。</span><br></code></pre></td></tr></table></figure><ul><li>json.dump<br>把python对象转换成json对象生成一个fp的文件流，和文件相关。python对象转换为字符串并且写入文件</li></ul> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-comment">#将python对象转换为json字符串</span><br>persons = [<br>    &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&quot;zhaoji&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span>,<br>        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;China&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;cyj&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span>,<br>        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;China&quot;</span><br>    &#125;<br>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/j1.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(persons, fp) // 将person存成文件<br></code></pre></td></tr></table></figure><ul><li>json.loads是用来读取字符串,可以把文件打开，用readline()读取一行，然后json.loads()一行。</li><li>json.load是用来读取文件的，即，将文件打开然后就可以直接读取。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相似模型</title>
      <link href="/2022/04/01/python-similar-model/"/>
      <url>/2022/04/01/python-similar-model/</url>
      
        <content type="html"><![CDATA[<h3 id="常见相似算法"><a href="#常见相似算法" class="headerlink" title="常见相似算法"></a>常见相似算法</h3><ol><li>欧德里得距离</li><li>皮尔逊相关系数</li><li>余弦相似度</li><li>Tanimoto系数（广义Jaccard相似系数）</li></ol><h4 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h4><p>Pearson 相关系数是用<strong>协方差</strong><em><strong>除以</strong></em>两个变量的<strong>标准差</strong>得到的，虽然协方差能反映两个随机变量的相关程度（协方差大于0的时候表示两者正相关，小于0的时候表示两者负相关），但其数值上受量纲的影响很大，不能简单地从协方差的数值大小给出变量相关程度的判断。为了消除这种量纲的影响，于是就有了相关系数的概念。<br>当两个变量的方差都不为零时，相关系数才有意义，相关系数的取值范围为[-1,1]。《数据挖掘导论》中给了一个很形象的图来说明相关度大小与相关系数之间的联系：</p><p><img src="/image/similar-model/pearson.png" alt="皮尔逊相关系数" title="皮尔逊相关系数"></p><p>由上图可以总结，当相关系数为1时，成为完全正相关；当相关系数为-1时，成为完全负相关；相关系数的绝对值越大，相关性越强；相关系数越接近于0，相关度越弱。</p><p><strong>皮尔逊相关的约束条件:</strong></p><ul><li>两个变量间有线性关系</li><li>变量是连续变量</li><li>变量均符合正态分布,且二元分布也符合正态分布</li><li>两变量独立</li></ul><p>在实践统计中,一般只输出两个系数,一个是相关系数,也就是计算出来的相关系数大小,在-1到1之间;另一个是独立样本检验系数,用来检验样本一致性.</p><h4 id="相似患者模型流程"><a href="#相似患者模型流程" class="headerlink" title="相似患者模型流程"></a>相似患者模型流程</h4><ol><li>相似患者模型流程</li></ol><p><img src="/image/similar-model/process.png" alt="相似患者模型流程" title="相似患者模型流程"><br>2. 相似患者模型</p><p><img src="/image/similar-model/similar-model.jpg" alt="相似患者模型" title="相似患者模型"><br>3. 相似患者功能</p><p><img src="/image/similar-model/function.png" alt="相似患者功能" title="相似患者功能"></p>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sk-learn</title>
      <link href="/2022/04/01/python-sk-learn/"/>
      <url>/2022/04/01/python-sk-learn/</url>
      
        <content type="html"><![CDATA[<h3 id="安装sk-learn"><a href="#安装sk-learn" class="headerlink" title="安装sk-learn"></a>安装sk-learn</h3><h4 id="pip-简介"><a href="#pip-简介" class="headerlink" title="pip 简介"></a>pip 简介</h4><p>Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一.</p><p>Sklearn 包含了很多种机器学习的方式:</p><p>Classification 分类</p><p>Regression 回归</p><p>Clustering 非监督分类</p><p>Dimensionality reduction 数据降维</p><p>Model Selection 模型选择</p><p>Preprocessing 数据预处理</p><h4 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装条件</span><br><span class="hljs-comment"># Python (&gt;=2.6 或 &gt;=3.3 版本)</span><br><span class="hljs-comment"># Numpy (&gt;=1.6.1)</span><br><span class="hljs-comment"># Scipy (&gt;=0.9)</span><br><br><span class="hljs-comment"># python 2+ 版本</span><br>pip install sciket-learn<br><br><span class="hljs-comment"># python 3+ 版本</span><br>pip3 install sciket-learn<br><br><span class="hljs-comment">#如果你是 Windows 用户, 你也可以选择使用 Anaconda 来安装所有 python 的科学计算模块. Anaconda的相关资料在这</span><br></code></pre></td></tr></table></figure><h4 id="sk-learn-工作流程"><a href="#sk-learn-工作流程" class="headerlink" title="sk-learn 工作流程"></a>sk-learn 工作流程</h4><ol><li>实例化要使用的特定机器学习模型</li><li>使模型适合训练数据</li><li>使用模型进行预测</li><li>评估预测的准确性</li></ol><h4 id="sk-learn-数据集分割"><a href="#sk-learn-数据集分割" class="headerlink" title="sk-learn 数据集分割"></a>sk-learn 数据集分割</h4><ol><li><p>留出法<br>基本思想是将数据集D（即我们获得的所有样本数据）划分为两个互斥的集合，将其中一个作为训练集S，另一个作为验证集T，即D=SUT，S∩T=Φ。在S上训练出模型后，再用T来评估其测试误差，作为泛化误差的估计值；</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train, X_test, y_train, y_test = train_test_split() <br><br><span class="hljs-comment"># X：待分割的样本集中的自变量部分，通常为二维数组或矩阵的形式；</span><br><span class="hljs-comment"># y：待分割的样本集中的因变量部分，通常为一维数组；</span><br><span class="hljs-comment"># test_size：用于指定验证集所占的比例，有以下几种输入类型：</span><br>　　  <span class="hljs-comment"># float型，0.0~1.0之间，此时传入的参数即作为验证集的比例；</span><br>　　  <span class="hljs-comment"># int型，此时传入的参数的绝对值即作为验证集样本的数量；</span><br>　　  <span class="hljs-comment"># None，这时需要另一个参数train_size有输入才生效，此时验证集去为train_size指定的比例或数量的补集；</span><br>　　  <span class="hljs-comment"># 缺省时为0.25，但要注意只有在train_size和test_size都不输入值时缺省值才会生效；</span><br><span class="hljs-comment"># train_size：基本同test_size，但缺省值为None，其实test_size和train_size输入一个即可；</span><br><span class="hljs-comment"># random_state：int型，控制随机数种子，默认为None，即纯随机（伪随机）；</span><br><span class="hljs-comment"># stratify：控制分类问题中的分层抽样，默认为None，即不进行分层抽样，当传入为数组时，则依据该数组进行分层抽样（一般传入因变量所在列）；</span><br><span class="hljs-comment"># shuffle：bool型，用来控制是否在分割数据前打乱原数据集的顺序，默认为True，分层抽样时即stratify为None时该参数必须传入False；</span><br></code></pre></td></tr></table></figure></li><li><p>交叉验证法</p></li><li><p>基于生成器的采样方法</p></li></ol><h4 id="sk-learn-数据缩放"><a href="#sk-learn-数据缩放" class="headerlink" title="sk-learn 数据缩放"></a>sk-learn 数据缩放</h4><ol><li><p>标准缩放（Standard Scaler）<br> StandardScaler假定你的数据正态分布在每个要素中，并将对其进行缩放，以使分布现在以0为中心，标准偏差为1。<br> 计算特征的平均值和标准偏差，然后根据以下条件对特征进行缩放：</p><p> <img src="/image/md-image/python%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE1.png" alt="&quot;标准缩放（Standard Scaler）&quot;" title="标准缩放（Standard Scaler）"><br> 如果数据<strong>不是正态分布</strong>的，那么这<strong>不算是最佳的缩放方法</strong>。</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler  <span class="hljs-comment"># 标准化工具</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x_np = np.array([[<span class="hljs-number">1.5</span>, -<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>],<br>              [<span class="hljs-number">2.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])<br>scaler = StandardScaler()<br>x_train = scaler.fit_transform(x_np)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;矩阵初值为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x_np))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该矩阵的均值为：&#123;&#125;\n 该矩阵的标准差为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(scaler.mean_,np.sqrt(scaler.var_)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;标准差标准化的矩阵为：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x_train))<br><br><span class="hljs-comment"># 矩阵初值为：[[ 1.5 -1.   2. ]</span><br><span class="hljs-comment">#             [ 2.   0.   0. ]]</span><br><span class="hljs-comment"># 该矩阵的均值为：   [ 1.75 -0.5   1.  ]</span><br><span class="hljs-comment"># 该矩阵的标准差为：[0.25 0.5  1.  ]</span><br><span class="hljs-comment"># 标准差标准化的矩阵为：[[-1. -1.  1.]</span><br><span class="hljs-comment">#                      [ 1.  1. -1.]]</span><br></code></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">StandardScaler()的方法<br>fit():<br>  <span class="hljs-number">1.</span> 功能：<br>    计算均值和标准差，用于以后的缩放。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组，形如(样本的数量，特征的数量)<br>      训练集<br>fit_transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    先计算均值、标准差，再标准化<br>  <span class="hljs-number">2.</span> 参数:<br>    X: 二维数组<br>transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    通过居中和缩放执行标准化。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组<br>      该数据沿着特征轴。<br>inverse_transform():<br>  <span class="hljs-number">1.</span> 功能：<br>    将数据按比例恢复到以前的大小。<br>  <span class="hljs-number">2.</span> 参数：<br>    X: 二维数组，形如(样本数量，特征数量)、<br>容易犯的错误<br>错误输入一维数组给fit_transform()、transform()。<br>原因是，标准化是对列操作的，一维数组每列中只有一个值，无法计算。<br>解决是，通过reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)，将一维数组改为二维数组。<br></code></pre></td></tr></table></figure></li><li><p>最大最小值缩放（Min-Max Scaler）</p></li><li><p>稳健缩放 （Roburst Scaler）</p></li><li><p>归一化（Normalizer）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sk-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2021/10/08/python-numpy/"/>
      <url>/2021/10/08/python-numpy/</url>
      
        <content type="html"><![CDATA[<h3 id="1-numpy简介"><a href="#1-numpy简介" class="headerlink" title="1.numpy简介"></a>1.numpy简介</h3><p>NumPy是用Python进行科学计算的基础软件包。<br>具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><ol><li>功能强大的N维数组对象。</li><li>精密广播功能函数。</li><li>集成 C/C+和Fortran 代码的工具。</li><li>强大的线性代数、傅立叶变换和随机数功能。</li></ol><h3 id="2-numpy环境安装"><a href="#2-numpy环境安装" class="headerlink" title="2.numpy环境安装"></a>2.numpy环境安装</h3><p>numpy 安装</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install numpy<br></code></pre></td></tr></table></figure><h3 id="3-numpy数组创建"><a href="#3-numpy数组创建" class="headerlink" title="3.numpy数组创建"></a>3.numpy数组创建</h3><p>ndarray：N维数组对象（矩阵），所有元素必须是相同类型。<br>ndarray属性：<code>ndim</code> 属性，表示维度个数；<code>shape</code> 属性，表示各维度大小；<code>dtype</code> 属性，表示数据类型。<br /><br><img src="/image/numpy-image/numpy-narray.png" alt="&quot;numpy创建数组&quot;" title="numpy创建数组"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例代码</span><br><br><span class="hljs-keyword">import</span> numpy;<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用列表生成一维数组&#x27;</span><br>data = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>x = numpy.array(data)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment">#打印数组</span><br><span class="hljs-built_in">print</span> x.dtype <span class="hljs-comment">#打印数组元素的类型</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用列表生成二维数组&#x27;</span><br>data = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br>x = numpy.array(data)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment">#打印数组</span><br><span class="hljs-built_in">print</span> x.ndim <span class="hljs-comment">#打印数组的维度</span><br><span class="hljs-built_in">print</span> x.shape <span class="hljs-comment">#打印数组各个维度的长度。shape是一个元组</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用zero/ones/empty创建数组:根据shape来创建&#x27;</span><br>x = numpy.zeros(<span class="hljs-number">6</span>) <span class="hljs-comment">#创建一维长度为6的，元素都是0一维数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3的二维0数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3的二维1数组</span><br><span class="hljs-built_in">print</span> x<br>x = numpy.empty((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#创建一维长度为2，二维长度为3,未初始化的二维数组</span><br><span class="hljs-built_in">print</span> x<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用arrange生成连续元素&#x27;</span><br><span class="hljs-built_in">print</span> numpy.arange(<span class="hljs-number">6</span>) <span class="hljs-comment"># [0,1,2,3,4,5,] 开区间</span><br><span class="hljs-built_in">print</span> numpy.arange(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment"># [0, 2，4]</span><br></code></pre></td></tr></table></figure><h3 id="4-ndarray数组元素的类型"><a href="#4-ndarray数组元素的类型" class="headerlink" title="4.ndarray数组元素的类型"></a>4.ndarray数组元素的类型</h3><p><img src="/image/numpy-image/numpy-dtype.jpg" alt="&quot;numpy创建数组&quot;" title="numpy创建数组"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例代码</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;生成指定元素类型的数组:设置dtype属性&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">3</span>],dtype = numpy.int64)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># 元素类型为int64</span><br><span class="hljs-built_in">print</span> x.dtype<br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],dtype = numpy.float64)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># 元素类型为float64</span><br><span class="hljs-built_in">print</span> x.dtype<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用astype复制数组，并转换类型&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">3</span>],dtype = numpy.float64)<br>y = x.astype(numpy.int32)<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [1 2 3]</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 1.   2.6  3. ]</span><br>z = y.astype(numpy.float64)<br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [ 1.  2.  3.]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;将字符串元素转换为数值元素&#x27;</span><br>x = numpy.array([<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>],dtype = numpy.string_)<br>y = x.astype(numpy.int32)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [&#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27;]</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [1 2 3] 若转换失败会抛出异常</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;使用其他数组的数据类型作为参数&#x27;</span><br>x = numpy.array([ <span class="hljs-number">1.</span>, <span class="hljs-number">2.6</span>,<span class="hljs-number">3.</span> ],dtype = numpy.float32);<br>y = numpy.arange(<span class="hljs-number">3</span>,dtype=numpy.int32);<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [0 1 2]</span><br><span class="hljs-built_in">print</span> y.astype(x.dtype) <span class="hljs-comment"># [ 0.  1.  2.]</span><br></code></pre></td></tr></table></figure><h3 id="5-ndarray的矢量化计算"><a href="#5-ndarray的矢量化计算" class="headerlink" title="5.ndarray的矢量化计算"></a>5.ndarray的矢量化计算</h3><p>矢量运算：相同大小的数组键间的运算应用在元素上<br>矢量和标量运算：“广播”— 将标量“广播”到各个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray数组与标量/数组的运算&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <br><span class="hljs-built_in">print</span> x*<span class="hljs-number">2</span> <span class="hljs-comment"># [2 4 6]</span><br><span class="hljs-built_in">print</span> x&gt;<span class="hljs-number">2</span> <span class="hljs-comment"># [False False  True]</span><br>y = numpy.array([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> x+y <span class="hljs-comment"># [4 6 8]</span><br><span class="hljs-built_in">print</span> x&gt;y <span class="hljs-comment"># [False False False]</span><br></code></pre></td></tr></table></figure><h3 id="6-ndarray数组的基本索引和切片"><a href="#6-ndarray数组的基本索引和切片" class="headerlink" title="6.ndarray数组的基本索引和切片"></a>6.ndarray数组的基本索引和切片</h3><p>一维数组的索引：与Python的列表索引功能相似;<br>多维数组的索引：</p><ol><li>arr[r1:r2, c1:c2]</li><li>arr[1,1] 等价 arr[1][1]</li><li>[:] 代表某个维度的数据</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的基本索引&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [1,2]</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-comment"># 2,普通python数组的索引</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] <span class="hljs-comment"># 同x[0][1]，ndarray数组的索引</span><br>x = numpy.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [[1 2],[3 4]]</span><br>y = x[<span class="hljs-number">0</span>].copy() <span class="hljs-comment"># 生成一个副本</span><br>z = x[<span class="hljs-number">0</span>] <span class="hljs-comment"># 未生成一个副本</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment">#  [[1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment"># 1</span><br>y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <br>z[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [[0 2],[3 4]]</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>] <span class="hljs-comment"># [[-1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [[-1 2],[3 4]]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的切片&#x27;</span><br>x = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment"># [2,3] 右边开区间</span><br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">3</span>] <span class="hljs-comment"># [1,2,3] 左边默认为 0</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">1</span>:] <span class="hljs-comment"># [2,3,4,5] 右边默认为元素个数</span><br><span class="hljs-built_in">print</span> x[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>] <span class="hljs-comment"># [1,3] 下标递增2</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">2</span>] <span class="hljs-comment"># [[1 2],[3 4]]</span><br><span class="hljs-built_in">print</span> x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] <span class="hljs-comment"># [[1],[3]]</span><br>x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> <span class="hljs-comment"># 用标量赋值</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[0,2],[0,4],[5,6]]</span><br>x[:<span class="hljs-number">2</span>,:<span class="hljs-number">1</span>] = [[<span class="hljs-number">8</span>],[<span class="hljs-number">6</span>]] <span class="hljs-comment"># 用数组赋值</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[8,2],[6,4],[5,6]]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy-api函数</title>
      <link href="/2021/10/08/python-numpy-api/"/>
      <url>/2021/10/08/python-numpy-api/</url>
      
        <content type="html"><![CDATA[<h3 id="1-ndarray通用函数"><a href="#1-ndarray通用函数" class="headerlink" title="1.ndarray通用函数"></a>1.ndarray通用函数</h3><p>通用函数（ufunc）是一种对ndarray中的数据执行元素级运算的函数。<br /></p><div style="display:flex;margin-top:10px">  <img src="/image/numpy-image/numpy-api.png" style="width:49%">  <img src="/image/numpy-image/numpy-2-api.png" style="width:49%"></div><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;一元ufunc示例&#x27;</span><br>x = numpy.arange(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [0 1 2 3 4 5]</span><br><span class="hljs-built_in">print</span> numpy.square(x) <span class="hljs-comment"># [ 0  1  4  9 16 25]</span><br>x = numpy.array([<span class="hljs-number">1.5</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">1.8</span>])<br>y,z = numpy.modf(x)<br><span class="hljs-built_in">print</span> y <span class="hljs-comment"># [ 0.5  0.6  0.7  0.8]</span><br><span class="hljs-built_in">print</span> z <span class="hljs-comment"># [ 1.  1.  1.  1.]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;二元ufunc示例&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]])<br>y = numpy.array([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">8</span>]])<br><span class="hljs-built_in">print</span> numpy.maximum(x,y) <span class="hljs-comment"># [[2,4],[6,8]]</span><br><span class="hljs-built_in">print</span> numpy.minimum(x,y) <span class="hljs-comment"># [[1,3],[5,7]]</span><br></code></pre></td></tr></table></figure><h3 id="2-NumPy的where函数"><a href="#2-NumPy的where函数" class="headerlink" title="2.NumPy的where函数"></a>2.NumPy的where函数</h3><p>p.where(condition, x, y)，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;where函数的使用&#x27;</span><br>cond = numpy.array([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>])<br>x = numpy.where(cond,-<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [-2  2 -2  2]</span><br>cond = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 2  2 -2 -2]</span><br>y1 = numpy.array([-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>])<br>y2 = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">2</span>,y1,y2) <span class="hljs-comment"># 长度须匹配</span><br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [1,2,-3,-4]</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;where函数的嵌套使用&#x27;</span><br>y1 = numpy.array([-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>,-<span class="hljs-number">5</span>,-<span class="hljs-number">6</span>])<br>y2 = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>y3 = numpy.zeros(<span class="hljs-number">6</span>)<br>cond = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>x = numpy.where(cond&gt;<span class="hljs-number">5</span>,y3,numpy.where(cond&gt;<span class="hljs-number">2</span>,y1,y2))<br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [ 1.  2. -3. -4. -5.  0.]</span><br></code></pre></td></tr></table></figure><h3 id="3-ndarray常用的统计方法"><a href="#3-ndarray常用的统计方法" class="headerlink" title="3.ndarray常用的统计方法"></a>3.ndarray常用的统计方法</h3><p>可以通过这些基本统计方法对整个数组/某个轴的数据进行统计计算。</p><ul><li><strong>sum:</strong> 对数组中全部或莫轴向的元素求和。0长度的数组sum为0</li><li><strong>mean:</strong> 算术平均数，0长度的数组mean为NaN</li><li><strong>std、var:</strong> 标准差和方差</li><li><strong>min、max</strong> 最大值和最小值</li><li><strong>argmin、argmax:</strong> 最大元素和最小元素的索引</li><li><strong>cumsum:</strong> 所有元素的累计和</li><li><strong>cumprod</strong> 所有元素的累计积  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;numpy的基本统计方法&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]) <span class="hljs-comment">#同一维度上的数组长度须一致</span><br><span class="hljs-built_in">print</span> x.mean() <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span> x.mean(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 对每一行的元素求平均</span><br><span class="hljs-built_in">print</span> x.mean(axis=<span class="hljs-number">0</span>) <span class="hljs-comment"># 对每一列的元素求平均</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment">#同理 12</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [3 6 3]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">max</span>() <span class="hljs-comment"># 3</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">max</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [2 3 2]</span><br><span class="hljs-built_in">print</span> x.cumsum() <span class="hljs-comment"># [ 1  3  6  9 10 12]</span><br><span class="hljs-built_in">print</span> x.cumprod() <span class="hljs-comment"># [ 1  2  6 18 18 36]</span><br></code></pre></td></tr></table></figure><p>用于布尔数组的统计方法：</p><ul><li><strong>sum:</strong> 统计数组/数组某一维度中的True的个数</li><li><strong>any:</strong> 统计数组/数组某一维度中是否存在一个/多个True</li><li><strong>all:</strong> 统计数组/数组某一维度中是否都是True</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;用于布尔数组的统计方法&#x27;</span><br>x = numpy.array([[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>],[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>]])<br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [1,1]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">any</span>(axis=<span class="hljs-number">0</span>) <span class="hljs-comment"># [True,False]</span><br><span class="hljs-built_in">print</span> x.<span class="hljs-built_in">all</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># [False,False]</span><br></code></pre></td></tr></table></figure><p>使用<strong>sort</strong>对数组/数组某一维度进行就地排序（会修改数组本身）。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;.sort的就地排序&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]])<br>x.sort(axis=<span class="hljs-number">1</span>) <br><span class="hljs-built_in">print</span> x <span class="hljs-comment"># [[1 2 6] [1 3 6] [1 2 5]]</span><br><span class="hljs-comment">#非就地排序：numpy.sort()可产生数组的副本</span><br></code></pre></td></tr></table></figure><h3 id="4-ndarray数组的去重以及集合运算"><a href="#4-ndarray数组的去重以及集合运算" class="headerlink" title="4.ndarray数组的去重以及集合运算"></a>4.ndarray数组的去重以及集合运算</h3><ul><li><strong>unique(x):</strong> 计算x中的唯一元素，并返回有序结果</li><li><strong>instersect1d(x,y):</strong> 计算x和y中的公共元素，并返回有序结果</li><li><strong>union1d(x,y):</strong> 计算x和y的并集，并返回有序结果</li><li><strong>in1d(x,y):</strong> 得到一个表示“x的元素是否包含于y”的布尔型数组</li><li><strong>setdiff1d(x,y):</strong> 集合的差，即元素在x中且不在y中</li><li><strong>setxor1d(x,y):</strong> 集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ndarray的唯一化和集合运算&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]])<br><span class="hljs-built_in">print</span> numpy.unique(x) <span class="hljs-comment"># [1,2,3,5,6]</span><br>y = numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span> numpy.in1d(x,y) <span class="hljs-comment"># [ True  True False  True  True False  True  True False]</span><br><span class="hljs-built_in">print</span> numpy.setdiff1d(x,y) <span class="hljs-comment"># [2 3]</span><br><span class="hljs-built_in">print</span> numpy.intersect1d(x,y) <span class="hljs-comment"># [1 5 6]</span><br></code></pre></td></tr></table></figure><h3 id="5-numpy中的线性代数"><a href="#5-numpy中的线性代数" class="headerlink" title="5.numpy中的线性代数"></a>5.numpy中的线性代数</h3><ul><li><strong>diag:</strong> 以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成方阵（非对角线元素为0）</li><li><strong>dot:</strong> 矩阵乘法</li><li><strong>trace:</strong> 计算对角线元素的和</li><li><strong>det:</strong> 计算矩阵行列式</li><li><strong>eig:</strong> 计算方阵的本征值和本征向量</li><li><strong>inv:</strong> 计算方阵的逆</li><li><strong>pinv:</strong> 计算矩阵的Moore-Penrose伪逆</li><li><strong>qr:</strong> 计算QR分解</li><li><strong>svd:</strong> 计算奇异值分解（SVD）</li><li><strong>solve:</strong> 解线性方程组Ax = b，其中A为一个方阵</li><li><strong>lstsq</strong> 计算Ax = b的最小二乘解</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;线性代数&#x27;</span><br><span class="hljs-keyword">import</span> numpy.linalg <span class="hljs-keyword">as</span> nla<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;矩阵点乘&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br>y = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]])<br><span class="hljs-built_in">print</span> x.dot(y) <span class="hljs-comment"># [[ 5 11][11 25]]</span><br><span class="hljs-built_in">print</span> numpy.dot(x,y) <span class="hljs-comment"># # [[ 5 11][11 25]]</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;矩阵求逆&#x27;</span><br>x = numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]])<br>y = nla.inv(x) <span class="hljs-comment"># 矩阵求逆（若矩阵的逆存在）</span><br><span class="hljs-built_in">print</span> x.dot(y) <span class="hljs-comment"># 单位矩阵 [[ 1.  0.][ 0.  1.]]</span><br><span class="hljs-built_in">print</span> nla.det(x) <span class="hljs-comment"># 求行列式</span><br></code></pre></td></tr></table></figure><h3 id="6-numpy中的随机数生成"><a href="#6-numpy中的随机数生成" class="headerlink" title="6.numpy中的随机数生成"></a>6.numpy中的随机数生成</h3>]]></content>
      
      
      <categories>
          
          <category> python 库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ai 机器学习初识</title>
      <link href="/2021/08/20/python-ai/"/>
      <url>/2021/08/20/python-ai/</url>
      
        <content type="html"><![CDATA[<h4 id="机器学习流程"><a href="#机器学习流程" class="headerlink" title="机器学习流程"></a>机器学习流程</h4><ol><li><p>模型选择:选择对应<strong>模型算法</strong>（例如：线性回归、逻辑回归、神经网络、决策树、支持向量机）</p></li><li><p>模型理解:了解模型的<strong>使用场景</strong>、<strong>所需参数</strong>以及<strong>数学意义</strong></p></li><li><p>数据准备:为保证模型准确性需要求：1.数据足够<strong>多</strong>2.数据足够<strong>全</strong>3.数据足够<strong>权威</strong></p></li><li><p>轴确认:选择特征作为模型的<code>X</code>轴，选择模型需要预测的结果为<code>Y</code>轴</p></li><li><p>数据清洗:对数据进行<strong>分组统计</strong>，对特征值筛选（<strong>mRMR算法</strong> =&gt; 最大相关和最小冗余） 最后将<strong>特征缩放</strong></p><ul><li><strong>mRMR</strong>（Max-Relevance and Min-Redundancy）：在原始特征集合中找到与最终输出结果相关性最大（Max-Relevance），和特征彼此之间相关性最小的一组特征（Min-Redundancy）</li><li><strong>特征缩放</strong>：用来统一资料中的自变项或特征范围的方法，特征缩放可以使机器学习算法工作的更好。</li></ul></li><li><p>训练模型:随机选取一部分（70%） 运行模型算法（Y = kX + k₂X₂ ···）,大致算出每个特征的权重k</p><ul><li><strong>模型算法</strong>：例如sk-learn中的逻辑回归LogisticRegression</li></ul></li><li><p>模型存储:存储运行后的模型公式（输入为带有这些特征的数据，输出为正的概率和为负的概率）</p></li><li><p>模型验证:再选另外一部分（30%） 运行模型公式，推算出<strong>tp</strong>（预测为正，实现也为正）<strong>fp</strong>（预测为负，实现为正）<strong>tn</strong>（预测为负，实现为负） <strong>fn</strong>（预测为负，实现为正）</p></li><li><p>根据预测的准确度经过公式推导</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// (精度) 精确率</span><br>P = 识别出的正确的正样本的数目 / 预测为正样本的数目<br><span class="hljs-comment">// (召回率) 或覆盖率</span><br>R = 识别出的正确的正样本的数目 / 实际为正样本的数目 <br><span class="hljs-comment">// 调和平均值</span><br>F1 是精确度和召回率的 <br>F1 = 2P×R / P+R<br><span class="hljs-comment">// 精确度和召回率都高时， F1值也会高． </span><br><span class="hljs-comment">// F1值在1时达到最佳值（完美的精确度和召回率 也就是 P = 1 ， R = 1），</span><br><span class="hljs-comment">// 最差为0．在二元分类中， F1值是测试准确度的量度。</span><br><span class="hljs-attr">TP</span>: 预测为正， 实现为正<br><span class="hljs-attr">FP</span>: 预测为正， 实现为负<br><span class="hljs-attr">FN</span>: 预测为负，实现为正<br><span class="hljs-attr">TN</span>: 预测为负， 实现为负 <br></code></pre></td></tr></table></figure></li><li><p>把数据传给前端绘制对应的<strong>模型好坏ROC</strong>的曲线</p></li><li><p>模型预测:输入对应的特征值，使用存储的模型预测结果（输入为带有这些特征的数据，输出为正的概率和为负的概率）</p></li></ol><h4 id="技术支持-python路线"><a href="#技术支持-python路线" class="headerlink" title="技术支持(python路线)"></a>技术支持(python路线)</h4><ol><li>python 语言基础</li><li>numpy (python数据处理库)</li><li>pandas (python数据处理库基于numpy)</li><li>sk-learn (科学计算库，机器学习基础库)</li><li>tensorflow (张量)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断浏览器环境</title>
      <link href="/2021/04/20/js-runtimeEnvironment/"/>
      <url>/2021/04/20/js-runtimeEnvironment/</url>
      
        <content type="html"><![CDATA[<h1 id="navigator-userAgent"><a href="#navigator-userAgent" class="headerlink" title="navigator.userAgent"></a>navigator.userAgent</h1><p>最简单的方法就是分析浏览器的 <code>user agent</code> 字符串，它包含了设备信息。</p><p>JS 通过<code>navigator.userAgent</code>属性拿到这个字符串，只要里面包含<code>mobi</code>、<code>android</code>、<code>iphone</code>等关键字，就可以认定是移动设备。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Mobi|Android|iPhone/i</span>.test(navigator.userAgent)) &#123;<br>  <span class="hljs-comment">// 当前设备是移动设备</span><br>&#125;<br><br><span class="hljs-comment">// 另一种写法</span><br><span class="hljs-keyword">if</span> (<br>  navigator.userAgent.match(<span class="hljs-regexp">/Mobi/i</span>) ||<br>  navigator.userAgent.match(<span class="hljs-regexp">/Android/i</span>) ||<br>  navigator.userAgent.match(<span class="hljs-regexp">/iPhone/i</span>)<br>) &#123;<br>  <span class="hljs-comment">// 当前设备是移动设备</span><br>&#125;<br><br><span class="hljs-comment">// Chromium 系的浏览器，还有一个navigator.userAgentData属性，也是类似的作用。不同之处是它将 user agent 字符串解析为一个对象，该对象的mobile属性，返回一个布尔值，表示用户是否使用移动设备。</span><br><span class="hljs-keyword">const</span> isMobile = navigator.userAgentData.mobile; <br><br><span class="hljs-comment">//还有一个已经废除的navigator.platform属性，所有浏览器都支持，所以也可以用。它返回一个字符串，表示用户的操作系统。</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Android|iPhone|iPad|iPod/i</span>.test(navigator.platform) &#123;<br><span class="hljs-comment">// 当前设备是移动设备</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="window-screen-和-window-innerWidth"><a href="#window-screen-和-window-innerWidth" class="headerlink" title="window.screen 和 window.innerWidth"></a>window.screen 和 window.innerWidth</h1><p>通过屏幕宽度，判断是否为手机。</p><p><code>window.screen</code>对象返回用户设备的屏幕信息，该对象的<code>width</code>属性是屏幕宽度（单位为像素）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.screen.width &lt; <span class="hljs-number">500</span>) &#123;<br>  <span class="hljs-comment">// 当前设备是移动设备 </span><br>&#125;<br><br><span class="hljs-comment">// 如果屏幕宽度window.screen.width小于500像素，就认为是手机。</span><br><span class="hljs-comment">// 这个方法的缺点在于，如果手机横屏使用，就识别不了。</span><br><br></code></pre></td></tr></table></figure><p><code>window.innerWidth</code>返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getBrowserWidth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.innerWidth &lt; <span class="hljs-number">768</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xs&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.innerWidth &lt; <span class="hljs-number">991</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sm&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.innerWidth &lt; <span class="hljs-number">1199</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;md&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lg&quot;</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="window-orientation"><a href="#window-orientation" class="headerlink" title="window.orientation"></a>window.orientation</h1><p>侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。</p><p><code>window.orientation</code>属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.orientation !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 当前设备是移动设备 </span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意，iPhone 的 Safari 浏览器不支持该属性。</strong></p><h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>手机浏览器的 DOM 元素可以通过ontouchstart属性，为touch事件指定监听函数。桌面设备没有这个属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMobile</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;ontouchstart&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.documentElement); <br>&#125;<br><br><span class="hljs-comment">// 另一种写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMobile</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">&quot;TouchEvent&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="window-matchMedia"><a href="#window-matchMedia" class="headerlink" title="window.matchMedia()"></a>window.matchMedia()</h1><p>结合 CSS 来判断。</p><p>CSS 通过 media query（媒介查询）为网页指定响应式样式。如果某个针对手机的 media query 语句生效了，就可以认为当前设备是移动设备。</p><p><code>window.matchMedia()</code>方法接受一个 CSS 的 media query 语句作为参数，判断这个语句是否生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isMobile = <span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">&quot;only screen and (max-width: 760px)&quot;</span>).matches;<br></code></pre></td></tr></table></figure><p><code>window.matchMedia()</code>的参数是一个 CSS 查询语句，表示只对屏幕宽度不超过 700 像素的设备生效。它返回一个对象，该对象的<code>matches</code>属性是一个布尔值。如果是<code>true</code>，就表示查询生效，当前设备是手机。</p><p>除了通过屏幕宽度判断，还可以通过指针的精确性判断。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isMobile = <span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">&quot;(pointer:coarse)&quot;</span>).matches;<br><br><span class="hljs-keyword">let</span> isMobile = <span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">&quot;(any-pointer:coarse)&quot;</span>).matches;<br></code></pre></td></tr></table></figure><p>CSS 语句<code>pointer:coarse</code>表示当前设备的指针是不精确的。由于手机不支持鼠标，只支持触摸，所以符合这个条件。</p><p><code>pointer:coarse</code>只用来判断主指针，此外还有一个<code>any-pointer</code>命令判断所有指针。<code>any-pointer:coarse</code>表示所有指针里面，只要有一个指针是不精确的，就符合查询条件。</p><h1 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h1><p>也可以使用别人写好的工具包。比如 <a href="https://www.npmjs.com/package/react-device-detect" title="react-device-detect">react-device-detect</a><br>，它支持多种粒度的设备侦测。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> &#123;isMobile&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-device-detect&#x27;</span>;<br><br><span class="hljs-keyword">if</span> (isMobile) &#123;<br>  <span class="hljs-comment">// 当前设备是移动设备</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 随手摘要(string)</title>
      <link href="/2020/11/25/js-abstract-string/"/>
      <url>/2020/11/25/js-abstract-string/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>标签模板</strong> ：模板字符串的特殊功能，它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“<strong>标签模板</strong>”功能（tagged template）。<strong>标签模板</strong>其实不是模板，而是函数调用的一种特殊形式。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tag</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>tag<span class="hljs-string">`Hello <span class="hljs-subst">$&#123; a + b &#125;</span> world <span class="hljs-subst">$&#123; a * b &#125;</span>`</span>;<br><span class="hljs-comment">// 等同于</span><br>tag([<span class="hljs-string">&#x27;Hello &#x27;</span>, <span class="hljs-string">&#x27; world &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>], a + b, a * b);<br></code></pre></td></tr></table></figure></li><li><p><strong>String.fromCodePoint()</strong> : 用于从 Unicode 码点返回对应字符;</p><ul><li>方法主要是对ES5  <code>String.fromCharCode()</code> 补充</li><li>ES5 <code>String.fromCharCode()</code> 不能识别码点大于0xFFFF的字符。</li><li>ES6 <code>String.fromCodePoint()</code> 可以识别大于0xFFFF的字符</li><li>在作用上 与 <code>codePointAt()</code> 方法相反。</li></ul></li><li><p><strong>String.raw()</strong> : 该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例子</span><br><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`Hi\n<span class="hljs-subst">$&#123;<span class="hljs-number">2</span>+<span class="hljs-number">3</span>&#125;</span>!`</span> <span class="hljs-comment">// &quot;Hi\\n5!&quot;</span><br><span class="hljs-comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span><br><br><span class="hljs-comment">// 特殊的标签模板</span><br></code></pre></td></tr></table></figure></li><li><p><strong>codePointAt()</strong> ： 返回一个字符的码点 (实例方法)。</p><ul><li>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。<em><strong>ES6</strong></em> 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;𠮷&quot;</span>;<br><br>s.length <span class="hljs-comment">// 2</span><br>s.charAt(<span class="hljs-number">0</span>) <span class="hljs-comment">// &#x27;&#x27;</span><br>s.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &#x27;&#x27;</span><br>s.charCodeAt(<span class="hljs-number">0</span>) <span class="hljs-comment">// 55362</span><br>s.charCodeAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// 57271</span><br><br><span class="hljs-comment">// 汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 </span><br><span class="hljs-comment">// 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。</span><br><span class="hljs-comment">// 对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，</span><br><span class="hljs-comment">// 而且charAt()方法无法读取整个字符，</span><br><span class="hljs-comment">// charCodeAt()方法只能分别返回前两个字节和后两个字节的值。</span><br></code></pre></td></tr></table></figure><ul><li><code>codePointAt()</code> 方法的参数，是字符在字符串中的位置（默认从 0 开始）。方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;𠮷a&#x27;</span>;<br><br>s.codePointAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;20bb7&quot;</span><br>s.codePointAt(<span class="hljs-number">2</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;61&quot;</span><br><br><span class="hljs-comment">// 字符a在字符串s的正确位置序号应该是 1，</span><br><span class="hljs-comment">// 但是必须向codePointAt()方法传入 2。</span><br><br><span class="hljs-comment">// 解决方案1</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;𠮷a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> s) &#123;<br><span class="hljs-built_in">console</span>.log(ch.codePointAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>));<br>&#125;<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br><br><span class="hljs-comment">// 解决方案2</span><br><span class="hljs-keyword">let</span> arr = [...<span class="hljs-string">&#x27;𠮷a&#x27;</span>]; <span class="hljs-comment">// arr.length === 2</span><br>arr.forEach(<br><span class="hljs-function"><span class="hljs-params">ch</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(ch.codePointAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>))<br>);<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br></code></pre></td></tr></table></figure><ul><li>codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is32Bit</span>(<span class="hljs-params">c</span>) </span>&#123;<br><span class="hljs-keyword">return</span> c.codePointAt(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0xFFFF</span>;<br>&#125;<br><br>is32Bit(<span class="hljs-string">&quot;𠮷&quot;</span>) <span class="hljs-comment">// true</span><br>is32Bit(<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>normalize()</strong> ：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\u01D1&#x27;</span>===<span class="hljs-string">&#x27;\u004F\u030C&#x27;</span> <br><span class="hljs-comment">//false</span><br><span class="hljs-string">&#x27;\u01D1&#x27;</span>.normalize() === <span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.normalize()<br><span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。</span><br>    <span class="hljs-comment">// NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</span><br>    <span class="hljs-comment">// NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</span><br>    <span class="hljs-comment">// NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</span><br>    <span class="hljs-comment">// NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</span><br><br><span class="hljs-comment">// normalize方法目前不能识别三个或三个以上字符的合成。</span><br><span class="hljs-comment">// 这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>includes()</strong> ：返回布尔值，表示是否找到了参数字符串。(实例方法)</p><ul><li>参数1: 需要找的字符串</li><li>参数2: 表示开始搜索的位置。包括当前位置</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// true</span><br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>startsWith()</strong> ：返回布尔值，表示参数字符串是否在原字符串的头部。(实例方法)</p><ul><li>参数1: 需要找的字符串</li><li>参数2: 表示开始搜索的位置。包括当前位置</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br>s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>endsWith()</strong> ：返回布尔值，表示参数字符串是否在原字符串的尾部。(实例方法)</p><ul><li>参数1: 需要找的字符串</li><li>参数2: 表示最后的位置。不包括当前位置</li></ul> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span><br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span><br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>repeat()</strong> ：返回一个新字符串，表示将原字符串重复n次。(实例方法)</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0</span>) <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-comment">// 参数如果是小数，会被取整。</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">2.9</span>) <span class="hljs-comment">// &quot;nana&quot;</span><br><br><span class="hljs-comment">// 如果repeat的参数是负数或者Infinity，会报错。</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-literal">Infinity</span>)<br><span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// RangeError</span><br><br><span class="hljs-comment">// 如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。</span><br><span class="hljs-comment">// 0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">0.9</span>) <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-comment">// 参数NaN等同于 0。</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-comment">// 如果repeat的参数是字符串，则会先转换成数字。</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;na&#x27;</span>) <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">// &quot;nanana&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>padStart()<strong>，</strong>padEnd()</strong> ： 返回一个新字符串，padStart()用于头部补全，padEnd()用于尾部补全。(实例方法)</p><ul><li>参数1: 字符串补全生效的最大长度</li><li>参数2: 用来补全的字符串</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;abax&#x27;</span><br><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xaba&#x27;</span><br><br><span class="hljs-comment">// 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</span><br><span class="hljs-string">&#x27;xxx&#x27;</span>.padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xxx&#x27;</span><br><span class="hljs-string">&#x27;xxx&#x27;</span>.padEnd(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xxx&#x27;</span><br><br><span class="hljs-comment">// 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，</span><br><span class="hljs-comment">// 则会截去超出位数的补全字符串。</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0123456789&#x27;</span>)<br><span class="hljs-comment">// &#x27;0123456abc&#x27;</span><br><br><span class="hljs-comment">// 如果省略第二个参数，默认使用空格补全长度。</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>) <span class="hljs-comment">// &#x27;   x&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>) <span class="hljs-comment">// &#x27;x   &#x27;</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>trimStart()<strong>，</strong>trimEnd()</strong> ： 返回的都是新字符串，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。(实例方法)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.trim() <span class="hljs-comment">// &quot;abc&quot;</span><br>s.trimStart() <span class="hljs-comment">// &quot;abc  &quot;</span><br>s.trimEnd() <span class="hljs-comment">// &quot;  abc&quot;</span><br><br><span class="hljs-comment">// 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</span><br><span class="hljs-comment">// 浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>matchAll()</strong> ： 返回一个正则表达式在当前字符串的所有匹配(实例方法)</p></li><li><p><strong>replaceAll()</strong> ： 返回一个新字符串，不会改变原字符串。可以一次性替换所有匹配。(实例方法)</p><ul><li>参数1 ： 可以是一个字符串，也可以是一个全局的正则表达式（<strong>带有g修饰符</strong>）。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不报错</span><br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.replace(<span class="hljs-regexp">/b/</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="hljs-regexp">/b/</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>参数2: 可以是字符串也可以是函数</p><ol><li><p>是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p><ul><li><code>$&amp;</code>：匹配的字符串。</li><li><code>$ˋ</code>：匹配结果前面的文本。</li><li><code>$&#39;</code>：匹配结果后面的文本。</li><li><code>$n</code>：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li><li><code>$$</code>：指代美元符号$。</li></ul></li><li><p>是一个函数，该函数的返回值将替换掉第一个参数searchValue匹配的文本。</p></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// $&amp; 表示匹配的字符串，即`b`本身</span><br><span class="hljs-comment">// 所以返回结果与原字符串一致</span><br><span class="hljs-string">&#x27;abbc&#x27;</span>.replaceAll(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;$&amp;&#x27;</span>)<br><span class="hljs-comment">// &#x27;abbc&#x27;</span><br><br><span class="hljs-comment">// $` 表示匹配结果之前的字符串</span><br><span class="hljs-comment">// 对于第一个`b`，$` 指代`a`</span><br><span class="hljs-comment">// 对于第二个`b`，$` 指代`ab`</span><br><span class="hljs-string">&#x27;abbc&#x27;</span>.replaceAll(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;$`&#x27;</span>)<br><span class="hljs-comment">// &#x27;aaabc&#x27;</span><br><br><span class="hljs-comment">// $&#x27; 表示匹配结果之后的字符串</span><br><span class="hljs-comment">// 对于第一个`b`，$&#x27; 指代`bc`</span><br><span class="hljs-comment">// 对于第二个`b`，$&#x27; 指代`c`</span><br><span class="hljs-string">&#x27;abbc&#x27;</span>.replaceAll(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">`$&#x27;`</span>)<br><span class="hljs-comment">// &#x27;abccc&#x27;</span><br><br><span class="hljs-comment">// $1 表示正则表达式的第一个组匹配，指代`ab`</span><br><span class="hljs-comment">// $2 表示正则表达式的第二个组匹配，指代`bc`</span><br><span class="hljs-string">&#x27;abbc&#x27;</span>.replaceAll(<span class="hljs-regexp">/(ab)(bc)/g</span>, <span class="hljs-string">&#x27;$2$1&#x27;</span>)<br><span class="hljs-comment">// &#x27;bcab&#x27;</span><br><br><span class="hljs-comment">// $$ 指代 $</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.replaceAll(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;$$&#x27;</span>)<br><span class="hljs-comment">// &#x27;a$c&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>和 <strong>replace()</strong> 区别</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">replaceAll()<br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br><span class="hljs-comment">// &#x27;aa__cc&#x27;</span><br><br>replace()<br><span class="hljs-comment">// replace()只将第一个b替换成了下划线。</span><br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.replace(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br><span class="hljs-comment">// &#x27;aa_bcc&#x27;</span><br><span class="hljs-comment">// 如果要替换所有的匹配，不得不使用正则表达式的g修饰符。</span><br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.replace(<span class="hljs-regexp">/b/g</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br><span class="hljs-comment">// &#x27;aa__cc&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>at()</strong> ：方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。(实例方法)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.at(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;e&quot;</span><br>str.at(-<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;o&quot;</span><br><br><span class="hljs-comment">// 如果参数位置超出了字符串范围，at()返回undefined。</span><br>str.at(<span class="hljs-number">5</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 随手摘要(解构赋值)</title>
      <link href="/2020/11/24/js-deconstructionAssignment/"/>
      <url>/2020/11/24/js-deconstructionAssignment/</url>
      
        <content type="html"><![CDATA[<ol><li><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）；如果解构不成功，变量的值就等于<code>undefined</code>。</p></li><li><p>如果等号的右边不是数组（或者严格地说，<strong>不是可遍历的结构</strong>），那么将会报错。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">let</span> [foo] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> [foo] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> [foo] = <span class="hljs-literal">NaN</span>;<br><span class="hljs-keyword">let</span> [foo] = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> [foo] = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> [foo] = &#123;&#125;;<br><br><span class="hljs-comment">// 对于 Set 结构，也可以使用数组的解构赋值。</span><br><span class="hljs-keyword">let</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br><br><span class="hljs-comment">// 事实上，只要某种数据结构具有 Iterator 接口，</span><br><span class="hljs-comment">//都可以采用数组形式的解构赋值。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fibs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> a;<br>        [a, b] = [b, a + b];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();<br></code></pre></td></tr></table></figure></li><li><p>解构赋值允许指定默认值。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [foo = <span class="hljs-literal">true</span>] = [];<br>foo <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">undefined</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><br><span class="hljs-comment">// 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。</span><br><span class="hljs-comment">// 所以，只有当一个数组成员严格等于undefined，默认值才会生效。</span><br><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>] = [<span class="hljs-literal">undefined</span>];<br>x <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>];<br>x <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure></li><li><p>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，即只有在用到的时候，才会求值。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;aaa&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> [x = f()] = [<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 上面代码中，因为x能取到值，所以函数f根本不会执行。</span><br><span class="hljs-comment">// 上面的代码其实等价于下面的代码。</span><br><br><span class="hljs-keyword">let</span> x;<br><span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>    x = f();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</span><br><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [];     <span class="hljs-comment">// x=1; y=1</span><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [<span class="hljs-number">2</span>];    <span class="hljs-comment">// x=2; y=2</span><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// x=1; y=2</span><br><span class="hljs-keyword">let</span> [x = y, y = <span class="hljs-number">1</span>] = [];     <span class="hljs-comment">// ReferenceError: y is not defined</span><br></code></pre></td></tr></table></figure></li><li><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果解构失败，变量的值等于<code>undefined</code>。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>foo <span class="hljs-comment">// &quot;aaa&quot;</span><br>bar <span class="hljs-comment">// &quot;bbb&quot;</span><br><br><span class="hljs-keyword">let</span> &#123; baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>对象的解构赋值是下面形式的简写,对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。<strong>真正被赋值的是后者</strong>，而不是前者。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: foo, <span class="hljs-attr">bar</span>: bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br><br><span class="hljs-comment">// 对象的解构赋值的内部机制，</span><br><span class="hljs-comment">// 是先找到同名属性，</span><br><span class="hljs-comment">// 然后再赋给对应的变量。</span><br><span class="hljs-comment">// 真正被赋值的是后者，而不是前者。</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-comment">// &quot;aaa&quot;</span><br>foo <span class="hljs-comment">// error: foo is not defined</span><br><br><span class="hljs-comment">// 复杂例子</span><br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">let</span> arr = [];<br><br>(&#123; <span class="hljs-attr">foo</span>: obj.prop, <span class="hljs-attr">bar</span>: arr[<span class="hljs-number">0</span>] &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span> &#125;);<br><br>obj <span class="hljs-comment">// &#123;prop:123&#125;</span><br>arr <span class="hljs-comment">// [true]</span><br></code></pre></td></tr></table></figure></li><li><p>对象解构也可以用于嵌套结构的对象。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br><span class="hljs-attr">p</span>: [<br>    <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    &#123; <span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;World&#x27;</span> &#125;<br>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;<br>x <span class="hljs-comment">// &quot;Hello&quot;</span><br>y <span class="hljs-comment">// &quot;World&quot;</span><br><br><span class="hljs-comment">// 这时p是--模式--，不是--变量--，</span><br><span class="hljs-comment">// 因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</span><br><br><span class="hljs-keyword">let</span> &#123; p, <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;<br></code></pre></td></tr></table></figure></li><li><p>对象的解构赋值可以取到继承的属性。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(obj1, obj2);<br><br><span class="hljs-keyword">const</span> &#123; foo &#125; = obj1;<br>foo <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>默认值生效的条件和数组一样，对象的属性值严格等于undefined才生效</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;x = <span class="hljs-number">3</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-literal">undefined</span>&#125;;<br>x <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">var</span> &#123;x = <span class="hljs-number">3</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-literal">null</span>&#125;;<br>x <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure></li><li><p>注意点⚠️</p><ul><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 错误的写法</span><br><span class="hljs-keyword">let</span> x;<br>&#123;x&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// SyntaxError: syntax error</span><br><br><span class="hljs-comment">// 因为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。</span><br><span class="hljs-comment">// 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</span><br><span class="hljs-comment">// 正确的写法</span><br><span class="hljs-keyword">let</span> x;<br>(&#123;x&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(&#123;&#125; = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]);<br>(&#123;&#125; = <span class="hljs-string">&#x27;abc&#x27;</span>);<br>(&#123;&#125; = []);<br><span class="hljs-comment">// 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</span><br></code></pre></td></tr></table></figure></li><li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-number">0</span> : first, [arr.length - <span class="hljs-number">1</span>] : last&#125; = arr;<br>first <span class="hljs-comment">// 1</span><br>last <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>a <span class="hljs-comment">// &quot;h&quot;</span><br>b <span class="hljs-comment">// &quot;e&quot;</span><br>c <span class="hljs-comment">// &quot;l&quot;</span><br>d <span class="hljs-comment">// &quot;l&quot;</span><br>e <span class="hljs-comment">// &quot;o&quot;</span><br><br><span class="hljs-comment">// 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>len <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li><li><p>数值和布尔值的解构赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">toString</span>: s&#125; = <span class="hljs-number">123</span>;<br>s === <span class="hljs-built_in">Number</span>.prototype.toString <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">toString</span>: s&#125; = <span class="hljs-literal">true</span>;<br>s === <span class="hljs-built_in">Boolean</span>.prototype.toString <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。</span><br><span class="hljs-comment">// 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</span><br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: x &#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: y &#125; = <span class="hljs-literal">null</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure></li><li><p>圆括号问题</p><ul><li><p>不能使用圆括号的情况</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// （1）变量声明语句</span><br><span class="hljs-comment">// 全部报错</span><br><span class="hljs-keyword">let</span> [(a)] = [<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">x</span>: (c)&#125; = &#123;&#125;;<br><span class="hljs-keyword">let</span> (&#123;<span class="hljs-attr">x</span>: c&#125;) = &#123;&#125;;<br><span class="hljs-keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;<br><span class="hljs-keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">o</span>: (&#123; <span class="hljs-attr">p</span>: p &#125;) &#125; = &#123; <span class="hljs-attr">o</span>: &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><br><span class="hljs-comment">// (2）函数参数</span><br><span class="hljs-comment">// 函数参数也属于变量声明，因此不能带有圆括号。</span><br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">[(z)]</span>) </span>&#123; <span class="hljs-keyword">return</span> z; &#125;<br><span class="hljs-comment">// 报错</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">[z,(x)]</span>) </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br><br><span class="hljs-comment">// (3) 赋值语句的模式</span><br><br><span class="hljs-comment">// 全部报错</span><br>(&#123; <span class="hljs-attr">p</span>: a &#125;) = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">42</span> &#125;;<br>([a]) = [<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li><li><p>可以使用圆括号的情况</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//赋值语句的非模式部分，可以使用圆括号。</span><br>[(b)] = [<span class="hljs-number">3</span>]; <span class="hljs-comment">// 正确</span><br>(&#123; <span class="hljs-attr">p</span>: (d) &#125; = &#123;&#125;); <span class="hljs-comment">// 正确</span><br>[(<span class="hljs-built_in">parseInt</span>.prop)] = [<span class="hljs-number">3</span>]; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 随手摘要(let,const,var)</title>
      <link href="/2020/11/23/js-abstract-(let,const,var)/"/>
      <url>/2020/11/23/js-abstract-(let,const,var)/</url>
      
        <content type="html"><![CDATA[<ol><li><p>var命令会发生“<strong>变量提升</strong>”现象，即变量可以在声明之前使用，值为undefined。</p></li><li><p>如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“<strong>暂时性死区</strong>”（temporal dead zone，简称 TDZ）</p></li><li><p>下面代码正确运行，输出了 3 次abc。这表明<strong>函数内部的变量i与循环变量i不在同一个作用域</strong>，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br></code></pre></td></tr></table></figure></li><li><p>浏览器实现差异（只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<strong>let</strong>处理。）</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<strong>var</strong>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。<blockquote><p>环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p></blockquote></li></ul></li><li><p>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种写法，报错</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 第二种写法，不报错</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 不报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>const实际上保证的，<strong>并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</strong>。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [];<br>a.push(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">// 可执行</span><br>a.length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 可执行</span><br>a = [<span class="hljs-string">&#x27;Dave&#x27;</span>];    <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li><li><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">Object</span>.freeze(&#123;&#125;);<br><br><span class="hljs-comment">// 常规模式时，下面一行不起作用；</span><br><span class="hljs-comment">// 严格模式时，该行会报错</span><br>foo.prop = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure></li><li><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> constantize = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">Object</span>.freeze(obj);<br>    <span class="hljs-built_in">Object</span>.keys(obj).forEach( <span class="hljs-function">(<span class="hljs-params">key, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span> ) &#123;<br>        constantize( obj[key] );<br>        &#125;<br>    &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>es6 申明变量的6种方式。</p><ul><li>var命令</li><li>function命令</li><li>let 命令</li><li>const 命令</li><li>import命令</li><li>class命令</li></ul></li><li><p>javaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法一</span><br>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span><br>? <span class="hljs-built_in">window</span><br>: (<span class="hljs-keyword">typeof</span> process === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp;<br>    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp;<br>    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">global</span> === <span class="hljs-string">&#x27;object&#x27;</span>)<br>    ? <span class="hljs-built_in">global</span><br>    : <span class="hljs-built_in">this</span>);<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">var</span> getGlobal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123; <span class="hljs-keyword">return</span> self; &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>; &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">global</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">global</span>; &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;unable to locate global object&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，</span><br><span class="hljs-comment">//任何环境下，globalThis都是存在的，</span><br><span class="hljs-comment">//都可以从它拿到顶层对象，指向全局环境下的this。</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 随手摘要(number)</title>
      <link href="/2020/11/22/js-abstract-number/"/>
      <url>/2020/11/22/js-abstract-number/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在 JavaScript 里面，数字均为<strong>双精度浮点类型</strong>，即一个介于±2^−1023 和±2^+1024 之间的数字，或约为±10^−308 到±10^+308，数字精度为 53 位。整数数值仅在±(2^53 - 1) 的范围内可以表示准确。</p></li><li><p>JavaScript 最近添加了 BigInt 的支持，<strong>你不能让 BigInt 和 Number 直接进行运算，你也不能用 Math 对象去操作 BigInt</strong></p></li><li><p><strong>二进制</strong>数字语法是以零为开头，后面接一个小写或大写的拉丁文字母 B(<em><strong>0b</strong></em> 或者是 <em><strong>0B</strong></em>)。 假如 0b 后面的数字不是 0 或者 1，那么就会提示这样的语法错误</p></li><li><p>十进制可以以 0 开头，后面接其他十进制数字，但是假如下一个接的十进制数字小于 8，那么该数字将会被当做八进制处理。</p></li><li><p>在 ECMAScript 5 严格模式下禁止使用八进制语法。通过在八进制数字添加一个前缀 0 就可以被所有的浏览器支持; ECMAScript 6 中使用<strong>八进制</strong>数字是需要给一个数字添加前缀”<strong>0o</strong>“。</p></li><li><p><strong>十六进制</strong>数字语法是以零为开头，后面接一个小写或大写的拉丁文字母 X(<strong>0x</strong> 或者是 <strong>0X</strong>)。假如0x后面的数字超出规定范围 (0123456789ABCDEF)，那么就会提示这样的语法错误</p></li><li><p><strong>Number.parseFloat()</strong>: 把字符串参数解析成浮点数，和全局方法 parseFloat() 作用一致。</p></li><li><p><strong>Number.parseInt()</strong>: 把字符串解析成特定基数对应的整型数字，和全局方法 parseInt() 作用一致。</p></li><li><p><strong>Number.isFinite()</strong>: 判断传递的值是否为有限数字。</p></li><li><p><strong>Number.isInteger()</strong>: 判断传递的值是否为整数。</p></li><li><p><strong>Number.isNaN()</strong>: 判断传递的值是否为 NaN. More robust version of the original global isNaN().</p></li><li><p><strong>Number.isSafeInteger()</strong>: 判断传递的值是否为安全整数。</p></li><li><p><strong>Math</strong> 的方法</p><ul><li><p><strong>abs()</strong> ：绝对值</p></li><li><p><strong>sin()</strong>, <strong>cos()</strong>, <strong>tan()</strong> ：标准三角函数;参数为弧度</p></li><li><p><strong>asin()</strong>, <strong>acos()</strong>, <strong>atan()</strong>, <strong>atan2()</strong> : 反三角函数; 返回值为弧度</p></li><li><p><strong>sinh()</strong>, <strong>cosh()</strong>, <strong>tanh()</strong> : 双曲三角函数; 参数为弧度。</p></li><li><p><strong>asinh()</strong>, <strong>acosh()</strong>, <strong>atanh()</strong> : 反双曲三角函数;返回值为弧度。</p></li><li><p><strong>floor()</strong>, <strong>ceil()</strong> : 返回小于等于参数的最大整数；返回大于等于参数的最小整数</p></li><li><p><strong>min()</strong>, <strong>max()</strong> : 返回一个以逗号间隔的数字参数列表中的较小或较大值 (分别地)</p></li><li><p><strong>random()</strong> : 返回 0 和 1 之间的随机数。</p></li><li><p><strong>round()</strong> : 四舍五入和截断函数</p></li><li><p><strong>fround()</strong> : 将任意的数字转换为离它最近的单精度浮点数形式的数字。</p></li><li><p><strong>trunc()</strong> : 删除掉数字的小数部分和小数点，不管参数是正数还是负数。</p></li><li><p><strong>sqrt()</strong> : 函数返回一个数的平方根</p></li><li><p><strong>cbrt()</strong> : 函数返回任意数字的立方根。</p></li><li><p><strong>hypot()</strong> : 所有参数平方和的平方根</p></li><li><p><strong>sign()</strong> : 数字的符号，说明数字是否为正、负、零。共有 5 种返回值，分别是 1, -1, 0, -0, NaN. 代表的各是正数，负数，正零，负零，NaN。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue：watch，computed</title>
      <link href="/2020/11/03/vue-(data,computed,watch)/"/>
      <url>/2020/11/03/vue-(data,computed,watch)/</url>
      
        <content type="html"><![CDATA[<h3 id="重写结果"><a href="#重写结果" class="headerlink" title="重写结果"></a>重写结果</h3><p>实现基本的数据劫持、computed缓存、watch</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vue&quot;</span>;<br><br><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    &#125;;<br>  &#125;,<br><br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">total</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-built_in">this</span>.b;<br>    &#125;,<br>  &#125;,<br><br>  <span class="hljs-attr">watch</span>: &#123;<br>    a (newValue, oldValue) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;newValue&quot;</span>, newValue);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;oldValue&quot;</span>, oldValue)<br>    &#125;,<br><br>    b (newValue, oldValue) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;newValue&quot;</span>, newValue);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;oldValue&quot;</span>, oldValue)<br>    &#125;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 2</span><br><br><br>vm.a = <span class="hljs-number">100</span><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 100</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 102</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 2</span><br><br>vm.b = <span class="hljs-number">200</span><br><span class="hljs-built_in">console</span>.log(vm.a);<span class="hljs-comment">// 100</span><br><span class="hljs-built_in">console</span>.log(vm.total);<span class="hljs-comment">// 300</span><br><span class="hljs-built_in">console</span>.log(vm.b);<span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure><h3 id="重写思路"><a href="#重写思路" class="headerlink" title="重写思路"></a>重写思路</h3><h4 id="暴露外部js"><a href="#暴露外部js" class="headerlink" title="暴露外部js"></a>暴露外部js</h4><ol><li>路径：/vue/index</li><li>思路：整合reactive、computed和watch并暴露vue的构造函数</li><li>代码</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> reactive <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reactive&quot;</span><br><span class="hljs-keyword">import</span> Computed <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./computed&#x27;</span><br><span class="hljs-keyword">import</span> Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watch&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">options</span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123; data, computed, watch &#125; = options<br>    <span class="hljs-built_in">this</span>.$data = data()<br><br>    <span class="hljs-built_in">this</span>.init(computed, watch)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">computed, watch</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.initData()<br>    <span class="hljs-built_in">this</span>.$computed =  <span class="hljs-built_in">this</span>.initComputed(computed)<br>    <span class="hljs-built_in">this</span>.$watch =  <span class="hljs-built_in">this</span>.initWatcher(watch)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">initData</span>(<span class="hljs-params"></span>)</span>&#123;<br>    reactive(<span class="hljs-built_in">this</span>, <span class="hljs-function">(<span class="hljs-params">key,value</span>)=&gt;</span>&#123;<br><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">key, newValue, oldValue</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(newValue === oldValue) <span class="hljs-keyword">return</span><br>      <span class="hljs-built_in">this</span>.$computed.update(key)<br>      <span class="hljs-built_in">this</span>.$watch.trigger(key, newValue, oldValue)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initComputed</span>(<span class="hljs-params">computed</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> computedIns = <span class="hljs-keyword">new</span> Computed()<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> computed)&#123;<br>      computedIns.addComputed(<span class="hljs-built_in">this</span>, computed, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> computedIns<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initWatcher</span>(<span class="hljs-params">watch</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> watcherIns = <span class="hljs-keyword">new</span> Watcher()<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> watch)&#123;<br>      watcherIns.addWatcher(<span class="hljs-built_in">this</span>, watch, key)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> watcherIns<br>  &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Vue<br></code></pre></td></tr></table></figure><h4 id="reactive数据劫持"><a href="#reactive数据劫持" class="headerlink" title="reactive数据劫持"></a>reactive数据劫持</h4><ol><li>路径：/vue/reactive.js</li><li>思路：利用Object.defineProperty实现数据劫持并利用回调返回get，set</li><li>代码</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span> (<span class="hljs-params">vm, __get__, __set__</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> _data = vm.$data<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> _data)&#123;<br>    <span class="hljs-built_in">Object</span>.defineProperty(vm, key, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        __get__(key, _data[key])<br>        <span class="hljs-keyword">return</span> _data[key]<br>      &#125;,<br><br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> oldValue = _data[key]<br>        _data[key] = newValue<br>        __set__(key, newValue, oldValue)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reactive<br></code></pre></td></tr></table></figure><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><ol><li><p>路径：/vue/computed</p></li><li><p>思路：用数组保存所有的computed数据，并将计算属性名称挂载在实例上，数据结构为</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">              key(计算属性的名称)<br>对象数组 --&gt;  value(缓存的计算属性返回的值)<br>              dep(计算属性需要更新的变量)<br>              get(计算属性求值的函数)<br></code></pre></td></tr></table></figure></li><li><p>代码</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computed</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.computedData = [];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">addComputed</span>(<span class="hljs-params">vm, computed, key</span>)</span> &#123;<br><span class="hljs-keyword">const</span> descript = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(computed, key);<br><br><span class="hljs-keyword">const</span> descriptFn = descript.value.get ? descript.value.get : descript.value,<br>get = descriptFn.bind(vm),<br>value = get(),<br>dep = <span class="hljs-built_in">this</span>._collectDep(descriptFn);<br><br>    <span class="hljs-built_in">this</span>.computedData.push(&#123;<br>      get,<br>      key,<br>      value,<br>      dep<br>    &#125;)<br><br>    <span class="hljs-keyword">let</span> _data = <span class="hljs-built_in">this</span>.computedData.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.key == key)<br><br>    <span class="hljs-built_in">Object</span>.defineProperty(vm, key, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> _data.value<br>      &#125;<br>    &#125;)<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">key, cb</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.computedData.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>      <span class="hljs-keyword">let</span> _key = item.dep.find(<span class="hljs-function"><span class="hljs-params">itemKey</span> =&gt;</span> itemKey == key)<br>      <span class="hljs-keyword">if</span>(_key)&#123;<br>        item.value = item.get()<br>        cb &amp;&amp; cb()<br>      &#125;<br>    &#125;)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">_computedDataPush</span>(<span class="hljs-params">options</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.computedData.push(options)<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-title">_collectDep</span>(<span class="hljs-params">fn</span>)</span> &#123;<br><span class="hljs-keyword">let</span> match = fn.toString().match(<span class="hljs-regexp">/this\.([a-zA-Z_]+)/g</span>);<br><span class="hljs-keyword">return</span> match.map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>])<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Computed;<br><br></code></pre></td></tr></table></figure><h4 id="watch监听器"><a href="#watch监听器" class="headerlink" title="watch监听器"></a>watch监听器</h4><ol><li><p>路径：/vue/watch</p></li><li><p>思路:用数组保存所有watch数据，数据结构为</p> <figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">              key(监听器的名称)<br>对象数组 --&gt;   watchFn(监听变化执行的函数)<br></code></pre></td></tr></table></figure></li><li><p>代码：</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData = []<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">addWatcher</span>(<span class="hljs-params">vm, watch, key</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>._addWatchData(vm, key, watch[key])<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">key, newValue, oldValue</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(item.key == key)&#123;<br>        item.watchFn(newValue, oldValue)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br><br>  <span class="hljs-function"><span class="hljs-title">_addWatchData</span>(<span class="hljs-params">vm, key, watchFn</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.watcherData.push(&#123;<br>      key,<br>      <span class="hljs-attr">watchFn</span>:watchFn.bind(vm)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Watcher<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>灵活使用回调函数</li><li>object.definproperty的使用</li><li>computed解决方案</li><li>尽可能为以后扩展留回调</li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单发布订阅实现</title>
      <link href="/2020/06/03/js-releaseSubscription/"/>
      <url>/2020/06/03/js-releaseSubscription/</url>
      
        <content type="html"><![CDATA[<h2 id="任务需求"><a href="#任务需求" class="headerlink" title="任务需求"></a>任务需求</h2><ol><li>eventBus.$on(type, fn) 实现对<strong>type</strong>事件的订阅</li><li>eventBus.$emit(type, data) 实现对<strong>type</strong>事件的发布</li><li>eventBus.$off(type) 取消对<strong>type</strong>事件的订阅</li><li>eventBus.$once(type, fn) 实现对<strong>type</strong>事件只监听一次后取消监听</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li><p>用一个对象对存储所有type</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">type1</span>: ...,<br>    <span class="hljs-attr">type2</span>: ....,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用数组存储一个type的所有订阅事件</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">type1</span>: [fn1, fn2, ...],<br>    <span class="hljs-attr">type2</span>: [fn1, fn2, ...],<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在发布事件触发时对数组里面的对应type的数组逐一调用并传递参数</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> eventBus = &#123;<br>    <span class="hljs-attr">eventData</span>: &#123;&#125;,<br>    $on (type, fn) &#123;<br>        <span class="hljs-built_in">this</span>.eventData[type] = <span class="hljs-built_in">this</span>.eventData[type] || [];<br>        <span class="hljs-built_in">this</span>.eventData[type].push(fn);<br>    &#125;,<br>    $emit (type, message) &#123;<br>        <span class="hljs-built_in">this</span>.eventData[type] &amp;&amp; (<span class="hljs-built_in">this</span>.eventData[type] = <span class="hljs-built_in">this</span>.eventData[type].filter(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            item(message);<br>            <span class="hljs-keyword">if</span>(item.once) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;))<br>    &#125;,<br>    $once (type, fn) &#123;<br>        <span class="hljs-built_in">this</span>.eventData[type] = <span class="hljs-built_in">this</span>.eventData[type] || [];<br>        fn.once = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>.eventData[type].push(fn);<br>    &#125;,<br>    $off (type) &#123;<br>        <span class="hljs-built_in">this</span>.eventData[type] = [];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> 数组的特殊用法 </tag>
            
            <tag> 发布订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2019/11/03/web-Lazy-loading-of-images/"/>
      <url>/2019/11/03/web-Lazy-loading-of-images/</url>
      
        <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>在一些图片量比较大的场景（电商首页，小程序首页等），如果我们打开页面时就加载所有的图片，那势必会导致页面的卡顿以及白屏，给用户不好的体验，导致用户流失。</p></li><li><p>但是我们仔细想一下，用户真的需要我们显示所有图片一起展示吗？其实并不是，用户看到的只是浏览器可视区域的内容。所以从这个情况我们可以做一些优化，只显示用户可视区域内的图片，当用户触发滚动的瞬间再去请求显示给用户。</p></li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><h4 id="planA"><a href="#planA" class="headerlink" title="planA"></a>planA</h4><p>监听到scroll事件后，调用目标元素的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。计算目标元素的offsettop、屏幕高度、滚动条的高度之间的值确定元素是否显示在页面中</p><ul><li><p>img 标签有自定义属性 data-src</p></li><li><p>首屏展示可视区域内的图片 src 值 替换为 data-src</p></li><li><p>滚动出现在可视区域的图片即时展示 （重复第二步）</p></li><li><p>利用scroll事件函数判断目标元素是否显示在页面中（getBoundingClientRect()获取返回元素的大小及其相对于视口的位置）</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">viewHeight = <span class="hljs-built_in">window</span>.innerHeight<br>imgs = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;imgs&quot;</span>))<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 运用闭包 count 进行计数 避免已显示的图片重复参与循环</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = count; i &lt; imgs.length; i++) &#123;<br>            <span class="hljs-comment">// getBoundingClientRect()获取返回元素的大小及其相对于视口的位置</span><br>            <span class="hljs-comment">// 获取第i张图片是否在可视区域</span><br>            <span class="hljs-keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top<br>            <span class="hljs-keyword">if</span> (distance &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 图片在可视区域时设置图片的src 为 当前元素 data-src</span><br>                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>                imgs[i].removeAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>                <span class="hljs-comment">// 图片已被显示，下次从count + 1 张开始检查是否在可视区域</span><br>                count += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 添加滚动事件触发加载</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyLoad, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>至此我们已经初步完成了我们的懒加载，但是我们大家都知道，scroll这个事件实在太容易被触发了，用户一滚动鼠标就会触发很多次，如果一直滚势必会导致重复触发执行我们的事件，这也会导致我们的性能急剧下降，所以这就引出了我们的混合体 防抖节流 来优化我们的性能。</p><ul><li><p><strong>节流</strong><br>比如mouseover，resize这种事件，每当有变化的时候，就会触发一次函数，这样很浪费资源。就比如一个持续流水的水龙头，水龙头开到最大的时候很浪费水资源，将水龙头开得小一点，让他每隔200毫秒流出一滴水，这样能源源不断的流出水而又不浪费。而节流就是每隔n的时间调用一次函数，而不是一触发事件就调用一次，这样就会减少资源浪费。</p></li><li><p><strong>防抖</strong><br>A和B说话，A一直说，当A持续说了一段时间的话后停止讲话，过了10秒之后，我们判定A讲完了，B开始回答A的话；如果10秒内A又继续讲话，那么我们判定A没讲完，B不响应，等A再次停止后，我们再次计算停止的时间，如果超过10秒B响应，如果没有则B不响应。</p></li><li><p><strong>节流与防抖的区别</strong><br>节流与防抖的前提都是某个行为持续地触发，不同之处只要判断是要优化到减少它的执行次数还是只执行一次就行。</p></li></ul><h4 id="planB"><a href="#planB" class="headerlink" title="planB"></a>planB</h4><p>利用IntersectionObserver实现<br><strong>IntersectionObserver使用方法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(callback, option);<br></code></pre></td></tr></table></figure><p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 开始观察</span><br>io.observe(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>));<br><br><span class="hljs-comment">// 停止观察</span><br>io.unobserve(element);<br><br><span class="hljs-comment">// 关闭观察器</span><br>io.disconnect();<br></code></pre></td></tr></table></figure><p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">io.observe(elementA);<br>io.observe(elementB);<br></code></pre></td></tr></table></figure><h5 id="callback-参数"><a href="#callback-参数" class="headerlink" title="callback 参数"></a>callback 参数</h5><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<br>  <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(entries);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</p><h5 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h5><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<br>  time: <span class="hljs-number">1875.699999988079</span>,<br>  rootBounds: DOMRectReadOnly &#123;<br>    bottom: <span class="hljs-number">920</span>,<br>    height: <span class="hljs-number">1024</span>,<br>    left: <span class="hljs-number">0</span>,<br>    right: <span class="hljs-number">1024</span>,<br>    top: <span class="hljs-number">0</span>,<br>    width: <span class="hljs-number">920</span><br>  &#125;,<br>  boundingClientRect: DOMRectReadOnly &#123;<br>     <span class="hljs-comment">// ...</span><br>  &#125;,<br>  intersectionRect: DOMRectReadOnly &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  intersectionRatio: <span class="hljs-number">0.54</span>,<br>  target: element<br>&#125;<br></code></pre></td></tr></table></figure><p>每个属性的含义如下。</p><ul><li>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li>target：被观察的目标元素，是一个 DOM 节点对象</li><li>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li><li>boundingClientRect：目标元素的矩形区域的信息</li><li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li><li>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0</li></ul><h5 id="Option-对象"><a href="#Option-对象" class="headerlink" title="Option 对象"></a>Option 对象</h5><ol><li><p>threshold<br> threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> IntersectionObserver(<br>  <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;, <br>  &#123;<br>    <span class="hljs-attr">threshold</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1</span>]<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p> 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p></li><li><p>root 属性和 rootMargin 属性<br> 很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性</p><p> IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> opts = &#123; <br>  <span class="hljs-attr">root</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>),<br>  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;500px 0px&quot;</span> <br>&#125;;<br><br><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<br>  callback,<br>  opts<br>);<br></code></pre></td></tr></table></figure><p> 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。</p><p> 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p></li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="!!!注意点"></a>!!!<strong>注意点</strong></h5><ul><li><p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。</p></li><li><p>规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p></li></ul><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.JQ-VhVrsScl0rLNrPtMlcQHaE8?w=260&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7&quot;</span>,<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th?id=OIP-C.M9CUntHQGPvSO5JkAn5Y4AHaFA&amp;w=140&amp;h=100&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2&quot;</span>,<br>  <span class="hljs-string">&quot;https://tse1-mm.cn.bing.net/th?id=OIP-C.xsA-3qUw6cqmd8nRfxk6TQHaEK&amp;w=168&amp;h=100&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2&quot;</span>,<br>];<br><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">ios</span>) =&gt;</span> &#123;<br>  ios.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item.intersectionRatio) &#123;<br>      <span class="hljs-keyword">var</span> contain = item.target,<br>          image = <span class="hljs-keyword">new</span> Image();<br>      image.src = arr[n % <span class="hljs-number">3</span>];<br>      image.style.width = <span class="hljs-string">&quot;100%&quot;</span>;<br>      n++;<br>      image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        contain.appendChild(image);<br>        io.unobserve(contain);<br>      &#125;;<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">let</span> lis = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;test&quot;</span>);<br><br><span class="hljs-built_in">Array</span>.from(lis).forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  io.observe(item);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端设计思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(Array对象)实现队列</title>
      <link href="/2019/10/06/js-array-theQueue/"/>
      <url>/2019/10/06/js-array-theQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的特殊用法-队列"><a href="#数组的特殊用法-队列" class="headerlink" title="数组的特殊用法 - 队列"></a>数组的特殊用法 - 队列</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol><li><p>定义一个lazyMan函数</p></li><li><p>实现以下方法</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">         <br><span class="hljs-number">1.</span><br>lazyMan(<span class="hljs-string">&quot;hank&quot;</span>)<br>“!,my name is hank” <span class="hljs-comment">//打印</span><br>lazyMan(<span class="hljs-string">&quot;hank&quot;</span>).sleep(<span class="hljs-number">10</span>).eat(<span class="hljs-string">&quot;apple&quot;</span>)<br>         <br><span class="hljs-number">2.</span><br>lazyMan(<span class="hljs-string">&quot;hank&quot;</span>).sleep(<span class="hljs-number">10</span>).eat(<span class="hljs-string">&quot;apple&quot;</span>)<br>“!,my name is hank” <span class="hljs-comment">//打印</span><br><span class="hljs-comment">// wating 10s</span><br><span class="hljs-string">&quot;sleep after 10s&quot;</span> <span class="hljs-comment">//打印</span><br><span class="hljs-string">&quot;eat apple&quot;</span> <span class="hljs-comment">//打印</span><br>         <br><span class="hljs-number">3.</span><br>lazyMan(<span class="hljs-string">&quot;hank&quot;</span>).eat(<span class="hljs-string">&quot;apple&quot;</span>).eat(<span class="hljs-string">&quot;food&quot;</span>)<br>“!,my name is hank” <span class="hljs-comment">//打印</span><br><span class="hljs-string">&quot;eat apple&quot;</span> <span class="hljs-comment">//打印</span><br><span class="hljs-string">&quot;eat food&quot;</span> <span class="hljs-comment">//打印</span><br>         <br><span class="hljs-number">4.</span><br>lazyMan(<span class="hljs-string">&quot;hank&quot;</span>).sleepFirst(<span class="hljs-number">5</span>).eat(<span class="hljs-string">&quot;apple&quot;</span>)<br><span class="hljs-comment">// wating 5s</span><br><span class="hljs-string">&quot;sleep after 5s&quot;</span><br>“!,my name is hank”, <span class="hljs-comment">//打印</span><br><span class="hljs-string">&quot;eat apple&quot;</span> <span class="hljs-comment">//打印</span><br>        <br></code></pre></td></tr></table></figure></li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>为了函数调用后可以持续调用函数，函数调用后返回一个api对象保证链式调用</li><li>将所有函数执行保存在一个数组当中</li><li>从数组中弹出第一项并执行</li><li>在每一次函数调用结束后再从数组中弹出第一项的函数执行</li><li>直到数组项弹出undefind为止</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyMan</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> theQueue = [];<br>    <span class="hljs-keyword">const</span> next = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> fn = theQueue.shift();<br>        fn &amp;&amp; fn()<br>    &#125;;<br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> next(), <span class="hljs-number">0</span>);<br><br>    theQueue.push(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;!,my name is&quot;</span> + name);<br>        next();<br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> api = &#123;<br>        <span class="hljs-function"><span class="hljs-title">sleep</span>(<span class="hljs-params">number</span>)</span> &#123;<br>            theQueue.push(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sleep after &quot;</span> + number + <span class="hljs-string">&quot;s&quot;</span>);<br>                next()<br>            &#125;, number * <span class="hljs-number">1000</span>));<br>            <span class="hljs-keyword">return</span> api;<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params">content</span>)</span> &#123;<br>            theQueue.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;eat &quot;</span> + content);<br>                next();<br>            &#125;);<br>            <span class="hljs-keyword">return</span> api;<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">sleepFirst</span>(<span class="hljs-params">number</span>)</span> &#123;<br>            theQueue.unshift(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sleep after&quot;</span> + number + <span class="hljs-string">&quot;s&quot;</span>);<br>                next()<br>            &#125;, number * <span class="hljs-number">1000</span>));<br>            <span class="hljs-keyword">return</span> api;<br>        &#125;,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> api;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Array </tag>
            
            <tag> 数组的特殊用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础知识</title>
      <link href="/2019/04/05/js-foundation/"/>
      <url>/2019/04/05/js-foundation/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型和语法"><a href="#数据类型和语法" class="headerlink" title="数据类型和语法"></a>数据类型和语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>七种基本数据类型<ol><li>布尔值(Boolean),有两个值分别为：<code>true</code>和<code>false</code></li><li>null,一个表明null值的关键字，JavaScript 是大小写敏感的，因此null 与 Null、NULL或变体完全不同。</li><li>undefined, 和null一样的特殊关键字，undefined表示变量未赋值时的属性 </li><li>数字（Number），整数或浮点数，例如： 42 或者 3.14159。</li><li>任意精度的整数 (BigInt) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li><li>字符串（String），字符串是一串表示文本值的字符序列，例如：”Howdy” 。</li><li>代表（Symbol） ( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。</li></ol></li><li>对象(Object)</li></ul><h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><ol><li><p>在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">x = <span class="hljs-string">&quot;The answer is &quot;</span> + <span class="hljs-number">42</span> <span class="hljs-comment">// &quot;The answer is 42&quot;</span><br>y = <span class="hljs-number">42</span> + <span class="hljs-string">&quot; is the answer&quot;</span> <span class="hljs-comment">// &quot;42 is the answer&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;37&quot;</span> - <span class="hljs-number">7</span> <span class="hljs-comment">// 30</span><br><span class="hljs-string">&quot;37&quot;</span> + <span class="hljs-number">7</span> <span class="hljs-comment">// &quot;377&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>parseInt 方法只能返回整数，所以使用它会丢失小数部分。另外，调用 parseInt 时最好总是带上进制(radix) 参数，这个参数用于指定使用哪一种进制。将字符串转换为数字的另一种方法是使用一元加法运算符。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66a&quot;</span>) <span class="hljs-comment">// 66</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 54 以8进制66解析为10进制的54</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;66&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br>(<span class="hljs-number">54</span>).toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// 66 10进制的54解析为8进制的66</span><br><span class="hljs-string">&quot;54&quot;</span>.toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// 54 字符串则不会进制转换</span><br><br><span class="hljs-comment">// 一元加法运算符字符串转数字</span><br><span class="hljs-string">&quot;1.1&quot;</span> + <span class="hljs-string">&quot;1.1&quot;</span> = <span class="hljs-string">&quot;1.11.1&quot;</span><br>(+<span class="hljs-string">&quot;1.1&quot;</span>) + (+<span class="hljs-string">&quot;1.1&quot;</span>) = <span class="hljs-number">2.2</span><br><span class="hljs-comment">// 注意：加入括号为清楚起见，不是必需的。</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="流程控制与错误处理"><a href="#流程控制与错误处理" class="headerlink" title="流程控制与错误处理"></a>流程控制与错误处理</h2><h3 id="if…else…语句"><a href="#if…else…语句" class="headerlink" title="if…else…语句"></a>if…else…语句</h3><ol><li><p>if 条件错误的值（也被叫做Falsy值）</p><ul><li>false</li><li>undefined</li><li>null</li><li>0</li><li>NaN</li><li>空字符串（””） </li></ul><p> <em><strong>注意不报括（”   “中间有空格）当传递给条件语句所有其他的值，包括所有对象会被计算为真 。</strong></em></p></li><li><p>请不要混淆原始的布尔值true和false 与 Boolean对象的真和假。例如：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//结果视为真</span><br><span class="hljs-keyword">if</span> (b == <span class="hljs-literal">true</span>) <span class="hljs-comment">// 结果视为假</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="try…catch…finally…-语句"><a href="#try…catch…finally…-语句" class="headerlink" title="try…catch…finally… 语句"></a>try…catch…finally… 语句</h3><ol><li><p>简介</p><p> 如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。</p></li><li><p>catch 块<br> 可以用这个标识符来获取抛出的异常信息。在插入throw块时JavaScript创建这个标识符；标识符只存在于catch块的存续期间里；当catch块执行完成时，标识符不再可用。</p></li><li><p>finally块<br>finally块包含了在try和catch块完成后、下面接着try…catch的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(Array对象)</title>
      <link href="/2018/10/06/js-array/"/>
      <url>/2018/10/06/js-array/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-描述"><a href="#Array-描述" class="headerlink" title="Array 描述"></a>Array 描述</h3><p><code>JavaScript</code> 的 <code>Array</code> 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。<br>数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。</p><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ol><li><p><strong>数组forEach</strong></p><p> Array.prototype.forEach(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: undefined</li></ul><p> <strong>数组遍历</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>     <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>     <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>     <span class="hljs-keyword">var</span> thisArg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>         cb.apply(thisArg,[_arr[i],i,_arr])<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组map</strong></p><p> Array.prototype.map(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 返回由原数组映射出来的新数组，该数组中的每个元素是调用一次提供的函数后的返回值。</li></ul><p> <strong>数组map</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">var</span> result = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i &lt; _len ; i ++)&#123;<br>        result.push(cb.apply( _arg, [_arr[i], i, _arr]))<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>数组filter</strong></p><p> Array.prototype.filter(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 返回由原数组映射出来的新数组，该数组中的每个元素是调用一次提供的函数后的返回值是否为true；如果为true则将该项添加至新数组，反之不添加。</li></ul><p> <strong>数组filter</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">var</span> result = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        cb.apply(_arg, [_arr[i], i, _arr]) ? result.push(_arr[i]) : <span class="hljs-string">&quot;&quot;</span><br>            <br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组every</strong></p><p> Array.prototype.every(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 调用一次提供的函数后的返回值，如果全为真则返回true否则返回false</li></ul><p> <strong>数组every</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myEvery = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(cb.apply(_arg, [_arr[i], i, _arr]))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组some</strong></p><p> Array.prototype.some(callback,thisArg)</p><ul><li>callback回调函数: 参数包括(currentValue ,index, array)</li><li>thisArg(可选): callback中的this指向(当callback为箭头函数时无效)</li><li>returns返回值: 调用一次提供的函数后的返回值，如果有一个为真则返回true否则返回false</li></ul><p> <strong>数组some</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.mySome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> _arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-built_in">window</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!cb.apply(_arg, [_arr[i], i, _arr]))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组reduce</strong></p><p> Array.prototype.reduce(callback,initialValue)</p><ul><li>callback回调函数：参数包括(accumulator, currentValue ,index, array)</li><li>initialValue: accumulator初始值不传的话默认为数组第一项; 在没有初始值的空数组上调用 <code>reduce</code> 将报错。</li></ul><p> <strong>数组reduce</strong>重写</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,<br>        _len = <span class="hljs-built_in">this</span>.length,<br>        flag = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>,<br>        _initIndex = flag ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,<br>        _initialValue =  flag ?  _arr[<span class="hljs-number">0</span>] : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = _initIndex; i &lt; _len; i ++)&#123;<br>        _initialValue = cb(_initialValue, _arr[i], i, _arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _initialValue<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>数组reduceRight</strong></p><p> Array.prototype.reduceRight(callback,initialValue)</p><ul><li>callback回调函数：参数包括(accumulator, currentValue ,index, array)</li><li>initialValue: accumulator初始值不传的话默认为数组第一项; 在没有初始值的空数组上调用 <code>reduceRight</code> 将报错。</li></ul><p> <strong>数组reduceRight</strong>重写</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduceRight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">this</span>.length<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span><br>    <span class="hljs-keyword">var</span> _initIndex = flag ? _len - <span class="hljs-number">2</span>  : _len - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> _initialValue =  flag ?  _arr[_len - <span class="hljs-number">1</span>] : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = _initIndex; i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>        _initialValue = cb(_initialValue, _arr[i], i, _arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _initialValue<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(promise)</title>
      <link href="/2018/09/01/js-promise/"/>
      <url>/2018/09/01/js-promise/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h3><p>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。<br>存在意义：<strong>异步问题同步化解决方案</strong></p><h3 id="Promise-描述"><a href="#Promise-描述" class="headerlink" title="Promise 描述"></a>Promise 描述</h3><p>一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <code>promise</code>，以便在未来某个时候把值交给使用者。<br>一个 Promise 必然处于以下几种状态之一：</p><ul><li>待定（<code>pending</code>）: 初始状态，既没有被兑现，也没有被拒绝。</li><li>已兑现（<code>fulfilled</code>）: 意味着操作成功完成。</li><li>已拒绝（<code>rejected</code>）: 意味着操作失败。</li></ul><p>待定状态的 Promise 对象要么会通过一个值被兑现（<em>fulfilled</em>），要么会通过一个原因（错误）被拒绝（<em>rejected</em>）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。<br>因为 <code>Promise.prototype.then</code> 和  <code>Promise.prototype.catch</code> 方法返回的是 <code>promise</code>， 所以它们可以被链式调用。</p><h3 id="Promise-运行流程"><a href="#Promise-运行流程" class="headerlink" title="Promise 运行流程"></a>Promise 运行流程</h3><ol><li>executor会立即执行（同步执行）</li><li>然后将任务储存在微任务中</li><li>等待 构造函数中的 <code>resolve</code> 或 <code>reject</code> 执行，只有第一次执行有效，多次调用没有任何作用,如果一直<strong>没调用</strong>则永远不会触发 <code>then</code> 或者 <code>catch</code></li><li>等主线程执行完成，事件循环机制(<code>Event Loop</code>)从微任务中查看状态（有可执行的微任务调出来运行 <code>then</code> 或者 <code>catch</code> ）</li><li><code>then</code> 和 <code>catch</code> 会返回一个新的 <code>promise</code> 所以可以被链式调用且下一个 <code>then</code> 或者 <code>catch</code>传值为上一个 <code>then</code> 或者 <code>catch</code>函数的返回值。</li><li><code>catch</code> 类似 <code>switch-case</code>的 <code>default</code> 可以用来兜底</li></ol><p><strong>宏任务与微任务</strong></p><ul><li>宏任务（任务队列）：setTimeout产生的队列为宏任务</li><li>微任务（任务队列）：promise产生的队列为微任务</li></ul><blockquote><p>同一时间微任务的优先级会大于微任务</p><p>微任务 &gt; DOM渲染 &gt; 宏任务</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;executor&quot;</span>); r()&#125;)<br><span class="hljs-keyword">let</span> con = <span class="hljs-string">&quot;测试&quot;</span>;<br><span class="hljs-built_in">document</span>.write(con);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2&quot;</span>),<span class="hljs-number">0</span>)<br>p.then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;p3&quot;</span>))<br><span class="hljs-comment">// 执行顺序 executor =&gt; 1 =&gt; p3 =&gt; dom渲染 =&gt; s2</span><br></code></pre></td></tr></table></figure><h3 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a>Promise.all([])</h4><p>该方法接收一个Promise数组返回一个Promise，只有<strong>当该数组中的所有Promise完成</strong>后才会由pendding状态变为resolve<strong>执行then</strong>里面的回调函数，若数组中有<strong>任意一个或多个promise被拒绝</strong>则会执行<strong>失败回调</strong>，catch方法会捕获到首个被执行的 reject函数。该方法获得的成功结果的数组里面的数据顺序和接收到的promise数组顺序是一致的。</p><h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any([])"></a>Promise.any([])</h4><p>当传入的promise数组中有<strong>任意一个完成时就会终止</strong>，会忽略到所有被拒绝掉的promise，直到第一个promise完成。若传入<strong>所有的promise被拒绝则会执行拒绝回调</strong>。</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([])"></a>Promise.race([])</h4><p>当promise数组中任意一个promise被拒绝或者成功，则会<strong>采用第一个promise作为他的返回值</strong>。若为成功的执行then，若失败则执行catch。</p><h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled([])"></a>Promise.allSettled([])</h4><p>当给定的promise数组中的所有promise被拒绝后会返回一个拒绝的promise数组，与[]一一对应。<br>一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，未决议的 Promise将被异步完成。那时，所返回的 <strong>promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。</strong><br>对于<strong>每个结果对象，都有一个 status 字符串</strong>。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。</p>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript - 基础(this指向)</title>
      <link href="/2018/07/01/js-this/"/>
      <url>/2018/07/01/js-this/</url>
      
        <content type="html"><![CDATA[<h3 id="js-的默认-this-指向"><a href="#js-的默认-this-指向" class="headerlink" title="js 的默认 this 指向"></a>js 的默认 this 指向</h3><p>在浏览器中非严格模式 this 默认指向 <code>window</code> 或者 <code>self</code> 或者 <code>frames</code> 或者 <code>globalThis</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span> === self === frames === globalThis;<br></code></pre></td></tr></table></figure><p>在 nodejs 中非严格模式 this 默认指向 <code>global</code> 或者 <code>globalThis</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">global</span> === globalThis;<br></code></pre></td></tr></table></figure><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在浏览器中, window 对象同时也是全局对象：</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>); <span class="hljs-comment">// true</span><br><br>a = <span class="hljs-number">37</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 37</span><br><br><span class="hljs-built_in">this</span>.b = <span class="hljs-string">&quot;MDN&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.b); <span class="hljs-comment">// &quot;MDN&quot;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// &quot;MDN&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-built_in">this</span>.d = <span class="hljs-string">&quot;MDN&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.d); <span class="hljs-comment">// &quot;MDN&quot;</span><br><span class="hljs-built_in">console</span>.log(d); <span class="hljs-comment">// &quot;MDN&quot;</span><br><br>c = <span class="hljs-number">37</span>; <span class="hljs-comment">// 会报错 Uncaught ReferenceError: c is not defined</span><br></code></pre></td></tr></table></figure><blockquote><p>特别案例：类里面的方法会默认开启严格模式</p></blockquote><h3 id="JavaScript-的-this-原理"><a href="#JavaScript-的-this-原理" class="headerlink" title="JavaScript 的 this 原理"></a>JavaScript 的 this 原理</h3><h4 id="1、问题的由来"><a href="#1、问题的由来" class="headerlink" title="1、问题的由来"></a>1、问题的由来</h4><p>学懂 JavaScript 语言，一个标志就是理解下面两种写法，可能有不一样的结果。</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br> &#125;;<br><br><span class="hljs-keyword">var</span> foo = obj.foo;<br><br><span class="hljs-comment">// 写法一</span><br>obj.foo();<br><br><span class="hljs-comment">// 写法二</span><br>foo();<br></code></pre></td></tr></table></figure><p>上面代码中，虽然 obj.foo 和 foo 指向同一个函数，但是执行结果可能不一样。请看下面的例子。</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>     <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.bar);<br>     &#125;,<br>     <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span>,<br> &#125;;<br><br><span class="hljs-keyword">var</span> foo = obj.foo;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br><br>obj.foo(); <span class="hljs-comment">// 1</span><br>foo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="2、内存的数据结构"><a href="#2、内存的数据结构" class="headerlink" title="2、内存的数据结构"></a>2、内存的数据结构</h4><p>JavaScript 语言之所以有this的设计，跟内存里面的数据结构有关系。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>:  <span class="hljs-number">5</span> &#125;;<br></code></pre></td></tr></table></figure><p>上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。</p><p><img src="/image/md-image/%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"><br>也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。</p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。<br><img src="/image/md-image/obj%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    [[value]]: <span class="hljs-number">5</span><br>    [[writable]]: <span class="hljs-literal">true</span><br>    [[enumerable]]: <span class="hljs-literal">true</span><br>    [[configurable]]: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，foo属性的值保存在属性描述对象的value属性里面。</p><h4 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h4><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125; &#125;;<br></code></pre></td></tr></table></figure><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。<br><img src="/image/md-image/func%E5%86%85%E5%AD%98.png" alt="这是内存的图片" title="内存分配的图片"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    [[value]]: 函数的地址<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">f</span>: f &#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f()<br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f()<br></code></pre></td></tr></table></figure><h4 id="4、环境变量"><a href="#4、环境变量" class="headerlink" title="4、环境变量"></a>4、环境变量</h4><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">f</span>: f,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数f在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>。</p><p><img src="/image/md-image/func1.png" alt="函数调用" title="函数调用内存指向"><br>在obj环境执行，<code>this.x</code>指向<code>obj.x</code>。</p><p><img src="/image/md-image/func2.png" alt="函数调用" title="函数调用内存指向"><br>回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。</p><h4 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h4><ol><li><p>function.call(thisArg, arg1, arg2, …)</p><ul><li>thisArg: 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</li><li>arg1, arg2, …: 指定的参数列表</li></ul></li><li><p>function.apply(thisArg, [argsArray])</p><ul><li>this.arg: 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</li><li>argsArray: 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li></ul></li><li><p>function.bind(thisArg,arg1, arg2, …)</p><ul><li>thisArg: 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数<br>（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg</li><li>arg1, arg2, …: 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li><li>bind的多次绑定只有第一次是有效的且不会执行函数</li><li>返回一个<strong>新函数</strong></li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>this 的指向 是在执行上下文时才确定的, 并且确定后不可更改；</li><li>this 指向 <strong>其执行上下文的环境对象</strong>;</li><li>this简单判断依据（<strong>谁调用则this指向谁</strong>）</li><li><strong>严格</strong>模式下全局调用函数this不默认指向window而是undefined</li><li><strong>类</strong>中定义的方法中默认会开启严格模式</li><li>箭头函数不具备this属性所以箭头函数中的this来源于可访问上下文中的this</li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
